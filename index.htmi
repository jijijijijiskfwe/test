<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>게임 보드</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Noto-Sans-KR:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #1c1c1b;
            --bg-secondary: #1c1c1b;
            --bg-tertiary: #374151;
            --bg-board: rgba(36, 36, 36, 0.5);
            --border-primary: #D4B783;
            --border-secondary: #4b5563;
            --text-primary: #EAEAEA;
            --text-secondary: #B0B0C0;
            --text-tertiary: #888899;
            --accent-primary: #D4B783;
            --accent-secondary: #C1A26C;
            --modal-backdrop: rgba(0, 0, 0, 0.8);
            --log-move: #60A5FA;
            --log-damage: #F87171;
            --log-heal: #4ADE80; 
            --log-system: #FBBF24;
            --log-join: #4ADE80;
            --log-admin: #9333ea;
            --turn-highlight-color: #caa954;
            --bg-game-id: #1f2937;
            --bg-selection-overlay: linear-gradient(180deg, var(--bg-primary) 0%, rgba(36, 36, 36, 0.7) 100%);
            --mp-color: #3B82F6;
            
            --scrollbar-thumb: var(--accent-primary);
            --scrollbar-track: #2d2d2d;

            --skill-ring-color: rgba(212, 183, 131, 0.8);

            --turn-box-bg: rgba(55, 65, 81, 0.5); 
            --turn-box-border: var(--accent-primary);
            --summary-box-bg: rgba(212, 183, 131, 0.1);

            --gradient-start: #ffffff; 
            --gradient-end: var(--accent-primary);
            --pc-color: #4ADE80;
            --enemy-color: #F87171;
        }

        html.light {
            --bg-primary: #FDFBF6;
            --bg-secondary: #FFFFFF;
            --bg-tertiary: #E5E7EB;
            --bg-board: rgba(229, 231, 235, 0.8);
            --border-primary: #8C6A48;
            --border-secondary: #D1D5DB;
            --text-primary: #3A3226;
            --text-secondary: #574B3A;
            --text-tertiary: #6B7280;
            --accent-primary: #8C6A48;
            --accent-secondary: #A98A66;
            --turn-highlight-color: #D97706;
            --log-admin: #6D28D9;
            --bg-game-id: #E5E7EB;
            --bg-selection-overlay: linear-gradient(180deg, var(--bg-primary) 0%, rgba(229, 231, 235, 0.7) 100%);
            --mp-color: #1D4ED8;

            
            --scrollbar-thumb: var(--accent-primary);
            --scrollbar-track: #F0F0F0;

            
            --skill-ring-color: rgba(140, 106, 72, 0.8);

            
            --turn-box-bg: rgba(229, 231, 235, 0.5); 
            --turn-box-border: var(--accent-primary);
            --summary-box-bg: rgba(140, 106, 72, 0.1);

            
            --gradient-start: #3A3226; 
            --gradient-end: #000000;
            --pc-color: #16A34A;
            --enemy-color: #DC2626;
        }

        
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px; 
        }
        ::-webkit-scrollbar-track {
            background: var(--scrollbar-track);
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: var(--scrollbar-thumb);
            border-radius: 10px;
            opacity: 0.7; 
        }
        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-secondary);
        }
        
        
        #selection-list::-webkit-scrollbar {
            height: 6px;
        }
        #selection-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }
        html.light #selection-list::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.3);
        }

        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            transition: background-color 0.3s, color 0.3s;
            background-image: var(--page-background-image);
            background-size: cover; 
            background-position: center; 
            background-repeat: no-repeat;
            background-attachment: fixed; 
        }
        
        body, h1, h2, h3, h4, button, .font-title {
            font-family: 'Cinzel', 'Noto Sans KR', serif;
            letter-spacing: 0.5px;
        }
        
        body {
            padding-top: 250px; 
        }
        
        #game-board {
            display: grid;
            grid-template-columns: repeat(10, minmax(0, 1fr));
            grid-template-rows: repeat(10, minmax(0, 1fr));
            width: 100%;
            aspect-ratio: 1 / 1;
            max-width: 90vw;
            max-height: 90vh;
            background-color: var(--bg-board);
            border: 1px solid var(--border-secondary);
            background-size: cover;
            background-position: center;
        }
        .cell {
            border: 1px solid var(--border-secondary);
            position: relative;
            transition: background-color 0.2s;
        }

        .cell:hover {
            background-color: rgba(212, 183, 131, 0.1);
        }
        
        .cell.tile-obstacle {
            background-color: #4B5563;
            background-image: repeating-linear-gradient(45deg, rgba(0,0,0,.1) 0, rgba(0,0,0,.1) 2px, transparent 0, transparent 5px);
            cursor: not-allowed;
        }
        .cell.tile-damage {
            background-color: #991B1B;
            box-shadow: inset 0 0 10px rgba(248, 100, 100, 0.5);
            cursor: help;
        }
        .cell.tile-damage:hover {
            background-color: #EF4444;
        }

        .combat-range {
            outline: 2px solid transparent;
            outline-offset: -2px;
            transition: outline 0.2s, background-color 0.2s, box-shadow 0.2s;
            box-shadow: inset 0 0 12px;
        }

        .attack-range-move {
            background-color: rgba(212, 183, 131, 0.05);
            outline-color: var(--accent-primary);
            box-shadow: inset 0 0 12px var(--accent-primary);
        }

        .attack-range-skill {
            background-color: rgba(239, 68, 68, 0.05);
            outline-color: var(--log-damage);
            box-shadow: inset 0 0 12px var(--log-damage);
        }
        
        .heal-range-skill {
            background-color: rgba(74, 222, 128, 0.08);
            outline-color: var(--log-heal);
            box-shadow: inset 0 0 12px var(--log-heal);
        }

        .enemy-threat-range {
            background-color: rgba(200, 50, 50, 0.07);
        }
        .threat-range-foreshadow {
    background-color: rgba(239, 68, 68, 0.25); 
    outline: 1px solid rgba(239, 68, 68, 0.5);
    outline-offset: -1px;
}

        @keyframes turn-glow {
            0% { 
                box-shadow: 0 0 8px 2px var(--turn-highlight-color); 
            }
            50% { 
                box-shadow: 0 0 16px 5px var(--turn-highlight-color); 
            }
            100% { 
                box-shadow: 0 0 8px 2px var(--turn-highlight-color); 
            }
        }

        .character-token {
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s, filter 0.3s;
            position: absolute; 
            z-index: 20;
            top: 0;
            left: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid transparent;
        }

        .character-token.current-turn-glow { 
            border-color: var(--turn-highlight-color); 
        }
        .character-token.current-turn-glow::before {
            content: ''; 
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%; 
            
            z-index: -1; 
            
            animation: turn-glow 3s infinite ease-in-out;
        }
        .character-token.enemy-token {
            border-color: #ef4444;
        }
          .status-effect-icon {
            position: absolute;
            top: -5px; 
            right: -5px;
            font-size: 1.5rem; 
            z-index: 25; 
            pointer-events: none; 
            filter: drop-shadow(0 0 3px rgba(0, 0, 0, 1)); 
        }

        
        .character-token.show-hit-overlay::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background-color: rgba(255, 0, 0, 0.4);
            box-shadow: inset 0 0 10px rgba(255, 0, 0, 0.6);
            pointer-events: none;
        }

        @keyframes hit-effect {
            0%, 100% { transform: translate(0, 0) rotate(0); }
            20% { transform: translate(-3px, 0) rotate(-2deg); }
            40% { transform: translate(3px, 0) rotate(2deg); }
            60% { transform: translate(-3px, 0) rotate(-2deg); }
            80% { transform: translate(3px, 0) rotate(2deg); }
            50% { filter: brightness(1.7) drop-shadow(0 0 5px #ef4444); }
        }

        .hit-animation {
            animation: hit-effect 0.5s ease-in-out;
        }
        
        
        .character-token.show-heal-overlay::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background-color: rgba(0, 255, 0, 0.4); 
            box-shadow: inset 0 0 10px rgba(0, 255, 0, 0.6);
            pointer-events: none;
        }

        .action-speech-bubble {
    position: absolute;
    bottom: 110%; 
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(255, 255, 255, 0.9);
    color: #1c1c1b;
    padding: 4px 10px;
    border-radius: 12px;
    font-size: 0.8rem;
    font-weight: bold;
    white-space: nowrap;
    z-index: 35; 
    pointer-events: none; 
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    font-family: 'Noto Sans KR', sans-serif;
}


.action-speech-bubble::after {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    border: 6px solid transparent;
    border-top-color: rgba(255, 255, 255, 0.9);
}

        @keyframes heal-effect {
            0%, 100% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(1.1); filter: brightness(1.5) drop-shadow(0 0 5px #4ADE80); }
        }

        .heal-animation {
            animation: heal-effect 0.5s ease-in-out;
        }

        .ghost-preview-token {
    opacity: 0.6;
    border: 3px dashed var(--accent-primary);
    pointer-events: none; 
    filter: saturate(0.8);
}

        
        @keyframes bounce-arrow {
            0%, 100% { 
                transform: translateX(-50%) translateY(0); 
            }
            50% { 
                transform: translateX(-50%) translateY(-6px); 
            }
        }
        @keyframes enemy-turn-glow-animation {
    0%, 100% { box-shadow: 0 0 8px 2px var(--log-damage); }
    50% { box-shadow: 0 0 16px 5px var(--log-damage); }
}


.character-token.enemy-turn-glow {
    border-color: var(--log-damage); 
}
.character-token.enemy-turn-glow::before {
    content: '';
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    border-radius: 50%;
    z-index: -1;
    animation: enemy-turn-glow-animation 3s infinite ease-in-out;
}


.enemy-turn-marker {
    position: absolute;
    top: -1.5rem;
    left: 50%;
    transform: translateX(-50%);
    color: var(--log-damage); 
    font-size: 1.5rem;
    line-height: 1;
    animation: bounce-arrow 1s infinite ease-in-out;
    z-index: 30;
    filter: drop-shadow(0 0 5px rgba(0, 0, 0, 0.7));
    border-radius: 50%;
    padding: 0 4px;
    background-color: rgba(0,0,0,0.1);
    pointer-events: none;
}
        
        .turn-marker {
            
            position: absolute;
            top: -1.5rem; 
            left: 50%; 
            transform: translateX(-50%);
            color: var(--turn-highlight-color);
            font-size: 1.5rem; 
            line-height: 1;
            
            animation: bounce-arrow 1s infinite ease-in-out; 
            z-index: 30;
            
            
            filter: drop-shadow(0 0 5px rgba(0, 0, 0, 0.7)); 
            border-radius: 50%;
            padding: 0 4px; 
            background-color: rgba(0,0,0,0.1); 
            cursor: pointer;
        }
        
        .turn-marker:after {
           
           content: none;
        }
        

        
        .hp-mp-bar-container {
             position: absolute;
             bottom: 0;
             left: 0;
             width: 100%;
             z-index: 5;
             display: flex;
             flex-direction: column;
             gap: 1px; 
             padding: 1px 0; 
        }
        .hp-bar {
            height: 3px;
            background-color: #3b0707;
            overflow: hidden;
            width: 90%;
            margin: 0 auto;
            border-radius: 1px;
        }
        .mp-bar {
            height: 2px; 
            background-color: #111827;
            overflow: hidden;
            width: 90%;
            margin: 0 auto;
            border-radius: 1px;
        }
        .hp-fill { background-color: #EF4444; height: 100%; transition: width 0.3s; }
        .mp-fill { background-color: var(--mp-color); height: 100%; transition: width 0.3s; }

        html:not(.light) .character-token:not(.enemy-token) {
            box-shadow: 0 0 8px rgba(212, 183, 131, 0.4), 0 0 10px rgba(0,0,0,0.5);
        }
        .token-placeholder {
            font-size: 2rem;
            font-weight: bold;
            color: var(--accent-primary);
        }
        .character-token:hover {
            transform: scale(1.1);
        }  #game-board.targeting-active .character-token:hover {
            transform: none; 
        }
        .selected-character {
             box-shadow: 0 0 15px 3px var(--accent-primary);
             border-color: var(--accent-primary) !important;
        }
        .token-click-through {
            opacity: 0.7; 
            pointer-events: none; 
        }
        
        .form-input {
             background-color: var(--bg-tertiary);
             border: 1px solid var(--border-secondary);
             color: var(--text-primary);
             border-radius: 4px;
             padding: 0.5rem 0.75rem;
             width: 100%;
             transition: all 0.2s;
        }
        .form-input:focus {
            border-color: var(--accent-primary);
            box-shadow: 0 0 5px rgba(212, 183, 131, 0.5);
            outline: none;
            background-color: var(--bg-tertiary);
        }

        .panel {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-secondary);
            position: relative;
            box-shadow: 0 0 15px rgba(0,0,0, 0.2);
            border-image: linear-gradient(to bottom right, var(--accent-secondary), transparent) 1;
        }
        
        .modal-content {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-secondary);
            box-shadow: 0 0 25px rgba(212, 183, 131, 0.2);
        }
        .modal-backdrop {
            background-color: var(--modal-backdrop);
            backdrop-filter: blur(2px);
        }

        #character-selection-overlay {
            height: 250px; 
            background: var(--bg-selection-overlay);
            backdrop-filter: blur(4px);
            z-index: 40;
            border-bottom: 1px solid var(--border-secondary);
            transition: height 0.3s ease-in-out, background-color 0.3s;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
        }
        
        #character-selection-overlay.collapsed { height: 1rem; }
        
        #selection-list { 
            overflow-x: scroll; 
            white-space: nowrap; 
            -webkit-overflow-scrolling: touch; 
            justify-content: flex-start; 
        }
        #selection-list::-webkit-scrollbar {
            height: 6px;
        }
        #selection-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }
        html.light #selection-list::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.3);
        }

        .char-card-item {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 150px; 
            height: 200px; 
            min-width: 150px; 
            border-radius: 16px;
            overflow: hidden;
            position: relative;
            background-size: cover;
            background-position: center top; 
            transition: transform 0.3s ease, box-shadow 0.3s ease, border-color 0.3s;
            border: 1px solid var(--border-secondary);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
        }
        .card-placeholder { font-size: 4rem; color: var(--accent-primary); opacity: 0.5; }
        .char-card-item:hover { transform: translateY(-5px); box-shadow: 0 10px 20px rgba(212, 183, 131, 0.2); border-color: var(--accent-primary); }
        .char-card-item.selected { border-color: var(--accent-primary); transform: scale(1.05); box-shadow: 0 0 25px var(--accent-primary); }
        .char-card-item:not([draggable="true"]) { cursor: default; }
        .char-card-item[draggable="true"] { cursor: grab; }

        .char-card-item.enemy-card { border-color: #7f1d1d; }
        .char-card-item.enemy-card:hover { border-color: #ef4444; box-shadow: 0 10px 20px rgba(239, 68, 68, 0.2); }
        .char-card-item.enemy-card.selected { border-color: #ef4444; box-shadow: 0 0 25px #ef4444; }

        .char-card-item .char-card-info { background: linear-gradient(0deg, rgba(0,0,0,0.95) 0%, rgba(0,0,0,0.0) 60%); }
        html.light .char-card-item .char-card-info { 
             background: linear-gradient(0deg, rgba(200, 200, 200, 0.9) 0%, rgba(255, 255, 255, 0.0) 60%); 
             color: var(--text-primary);
        }
        html.light .char-card-item.enemy-card .char-card-info { 
             background: linear-gradient(0deg, rgba(255, 200, 200, 0.9) 0%, rgba(255, 255, 255, 0.0) 60%);
             color: var(--text-primary);
        }

        .enemy-card .details-btn { border-color: #991b1b; color: #f87171; }
        .enemy-card .details-btn:hover { border-color: #ef4444; color: #ef4444; }


        .char-card-info {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 10px; 
            height: 100%; 
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            color: var(--text-primary);
        }

        .turn-highlight {
            border: 1px solid #fBBF24;
            background-color: rgba(251, 191, 36, 0.05);
            box-shadow: 0 0 10px rgba(251, 191, 36, 0.2);
        }
        
        button { letter-spacing: 1px; border-radius: 2px; transition: all 0.2s ease; border: 1px solid var(--border-secondary); }
        button:hover { border-color: var(--accent-primary); color: var(--accent-primary); background-color: rgba(212, 183, 131, 0.1) !important; box-shadow: 0 0 10px rgba(212, 183, 131, 0.3); }
        button.bg-green-600 { background-color: var(--accent-primary) !important; color: var(--bg-primary) !important; font-weight: bold; border: none; }
        button.bg-red-600 { background-color: var(--log-damage) !important; color: var(--text-primary) !important; font-weight: bold; border: none; }
        
        #admin-panel-btn { background-color: var(--accent-primary); color: var(--bg-primary) !important; }

        .details-btn { background: transparent; border: 1px solid var(--accent-secondary); color: var(--accent-secondary); padding: 2px 8px; font-size: 0.75rem; border-radius: 2px; }

        #game-log-list li { background-color: transparent; padding: 4px 0; border: none; position: relative; padding-left: 1.75rem; line-height: 1.5; font-size: 0.8rem; font-family: 'Noto Sans KR', sans-serif; }
        #game-log-list li::before { content: '•'; position: absolute; left: 0.5rem; top: 4px; font-weight: bold; color: var(--accent-primary); }
        #game-log-list .log-move::before { color: var(--log-move); }
        #game-log-list .log-damage::before { color: var(--log-damage); }
        #game-log-list .log-heal::before { color: var(--log-heal); }
        #game-log-list .log-system::before { color: var(--log-system); }
        #game-log-list .log-join::before { color: var(--log-join); }
        #game-log-list .log-admin-move::before { color: var(--log-admin); }

        .profile-modal-container { 
    background: url('https://www.transparenttextures.com/patterns/dark-matter.png'), linear-gradient(to bottom right, #1a1a1a, #111111); 
    color: var(--text-primary); 
    border: 1px solid var(--accent-primary); 
    box-shadow: 0 0 30px rgba(212, 183, 131, 0.3); 
    display: grid; 
    grid-template-columns: 350px 1fr;
    width: 100%; 
    max-width: 900px; 
        height: 650px; 
    max-height: 90vh;
    overflow: hidden; 
    
    position: relative; 
}
        .profile-modal-container.enemy-profile { border-color: #ef4444; box-shadow: 0 0 30px rgba(239, 68, 68, 0.3); }
        .profile-modal-container.enemy-profile .profile-char-name, 
        .profile-modal-container.enemy-profile .stat-item svg, 
        .profile-modal-container.enemy-profile h3 { color: #f87171; }
        .profile-modal-container.enemy-profile #edit-char-btn { background-color: #991b1b; }
        .profile-modal-container.enemy-profile #edit-char-btn:hover { background-color: #ef4444 !important; }

        .profile-char-image { 
            width: 100%; 
            height: 100%; 
            background-size: cover; 
            background-position: center 20%; 
        }
        .profile-stats-panel { 
    padding: 2.5rem;
    background-color: rgba(0,0,0,0.1); 
    display: flex;
    flex-direction: column;
    height: 100%;
        overflow-y: auto; 
}
        .profile-char-name { font-size: 2.5rem; font-weight: bold; color: var(--accent-primary); margin-bottom: 0.5rem; }
        .profile-char-type { font-size: 1rem; color: var(--text-secondary); margin-bottom: 2rem; flex-shrink: 0; }
        .profile-stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; flex-shrink: 0; }
        .stat-item { display: flex; align-items: center; gap: 0.75rem; }
        .stat-item svg { width: 24px; height: 24px; color: var(--accent-secondary); }
        .stat-item .value { font-size: 1.25rem; font-weight: bold; }
        .stat-item .label { font-size: 0.8rem; color: var(--text-tertiary); }
        
        .profile-content-scroll {
            overflow-y: auto;
            flex-grow: 1;
            padding-right: 1rem;
            margin-right: -1rem;
        }
        
        .profile-content-scroll::-webkit-scrollbar { width: 8px; }
        .profile-content-scroll::-webkit-scrollbar-track { background: var(--scrollbar-track); }
        .profile-content-scroll::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 4px; }
        .profile-content-scroll::-webkit-scrollbar-thumb:hover { background: var(--accent-secondary); }

        #profile-modal #close-modal-btn { position: absolute; top: 1rem; right: 1rem; z-index: 10; background: none; border: none; }
        
        
        .profile-modal-container[style*="grid-template-columns: 1fr"] {
             height: auto; 
             min-height: 400px;
        }
        .profile-modal-container[style*="grid-template-columns: 1fr"] .p-6 {
            display: flex;
            flex-direction: column;
            height: 100%; 
        }
        .profile-modal-container[style*="grid-template-columns: 1fr"] .space-y-4 {
            overflow-y: auto;
            flex-grow: 1;
            padding-right: 1rem; 
            margin-right: -1rem;
        }
        .profile-modal-container[style*="grid-template-columns: 1fr"] .space-y-4::-webkit-scrollbar { width: 8px; }
        
        .profile-modal-container[style*="grid-template-columns: 1fr"] .space-y-4::-webkit-scrollbar-track { background: var(--scrollbar-track); }
        .profile-modal-container[style*="grid-template-columns: 1fr"] .space-y-4::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); }
        .profile-modal-container[style*="grid-template-columns: 1fr"] .space-y-4::-webkit-scrollbar-thumb:hover { background: var(--accent-secondary); }


        
        .info-button {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-secondary);
            color: var(--text-primary);
            transition: all 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .info-button:hover {
            background-color: var(--bg-tertiary);
            border-color: var(--accent-primary);
            color: var(--accent-primary);
        }
        
        .skill-btn {
            border-radius: 9999px;
            padding: 0.5rem 1rem;
            transition: all 0.3s ease;

            background-color: transparent; 
            color: var(--text-primary); 
            font-weight: bold;
            border: 1px solid var(--accent-primary);
        }
        
        .skill-btn:not([disabled]):hover {
            box-shadow: 0 0 10px var(--skill-ring-color), 0 0 5px var(--accent-primary) inset;
        }

        .skill-btn.ring-2 {
             box-shadow: 0 0 10px var(--skill-ring-color) !important;
        }

        
        #utility-controls {
            position: fixed;
            bottom: 8px;
            right: 8px;
            z-index: 50;
            display: flex;
            gap: 8px; 
            align-items: flex-end;
        }

        
        #turn-status.stylish-turn-box {
            
            background: linear-gradient(145deg, rgba(0, 0, 0, 0.4), rgba(0, 0, 0, 0.1));
            backdrop-filter: blur(2px);
            border: 2px solid var(--accent-primary);
            box-shadow: 0 0 15px rgba(212, 183, 131, 0.3); 
            padding: 0.75rem;
            border-radius: 8px;
            text-align: center;
        }
        html.light #turn-status.stylish-turn-box {
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.6), rgba(255, 255, 255, 0.1));
            box-shadow: 0 0 15px rgba(140, 106, 72, 0.2);
        }

        #turn-status.stylish-turn-box p {
            
             color: var(--accent-primary) !important; 
             font-weight: bold;
        }

        #turn-status.stylish-turn-box #current-turn-char {
             color: var(--accent-primary); 
        }
        
        
        #unit-summary {
             
             
             border-radius: 8px;
             padding: 0.75rem 0; 
             display: grid;
             grid-template-columns: 1fr 1fr;
             gap: 1rem;
             text-align: center;
             
        }
        #remaining-pc, #remaining-enemy {
            background-color: transparent; 
            padding: 0; 
            border-radius: 0;
            border: none;
        }

        
        .summary-count {
            font-size: 3rem; 
            font-weight: 700;
            display: inline-block;
            line-height: 1;
            
            background-clip: text;
            -webkit-background-clip: text;
            color: transparent;
            transition: all 0.3s;
        }
        #pc-count.summary-count {
            background-image: linear-gradient(180deg, var(--gradient-start), var(--pc-color));
        }
        #enemy-count.summary-count {
            background-image: linear-gradient(180deg, var(--gradient-start), var(--enemy-color));
        }

        #turn-announcement-backdrop {
            display: none; 
            position: fixed;
            inset: 0; 
            background-color: rgba(0, 0, 0, 0.75);
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            z-index: 100; 
            pointer-events: none; 
        }

        #turn-announcement-backdrop.visible {
            display: block;
            opacity: 1;
        }

        
        #turn-announcement {
            display: none;
            position: fixed;
            top: 45%;
            left: 50%;
            transform: translateX(-50%);
            z-index: 101; 
            
            color: var(--turn-highlight-color); 
            font-family: 'Cinzel', serif;
            font-weight: bold;
            text-align: center;
            white-space: nowrap;

            text-shadow: 
                -2px -2px 0 #000,  
                 2px -2px 0 #000,
                -2px  2px 0 #000,
                 2px  2px 0 #000,
                 0 0 15px rgba(0,0,0,0.8);
        }

        
        #turn-announcement .round-text {
            display: block;
            font-size: 1.5rem;
            font-weight: normal;
            opacity: 0.8;
            margin-bottom: 0.5rem;
            letter-spacing: 1px; 
        }

        #turn-announcement .turn-text {
            display: block;
            font-size: 3.5rem;
        }

        
        #turn-announcement.animate-turn {
            display: block;
            animation: turn-announce-animation 2.5s ease-in-out forwards;
        }
 

        #undo-move-btn, #end-turn-btn {
            color: white;
            border: none;
            padding-top: 0.5rem;
            padding-bottom: 0.5rem;
            font-weight: bold;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        #undo-move-btn:hover, #end-turn-btn:hover {
            transform: translateY(-2px); 
            filter: brightness(1.15); 
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        
        #undo-move-btn {
            background-image: linear-gradient(to top, #4b5563, #6b7280);
            color: var(--text-primary);
        }

        
        #end-turn-btn {
            background-image: linear-gradient(to top, var(--accent-secondary), var(--turn-highlight-color));
            color: var(--bg-primary); 
        }
        
        @keyframes turn-announce-animation {
            0% {
                transform: translateX(-150vw);
                opacity: 0;
            }
            15% {
                transform: translateX(-50%);
                opacity: 1;
            }
            45% {
                transform: translateX(-50%);
                opacity: 1;
                
                text-shadow: -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000, 2px 2px 0 #000, 0 0 15px rgba(0,0,0,0.8);
            }
            50% {
                
                text-shadow: 
                    -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000, 2px 2px 0 #000,
                    0 0 10px var(--turn-highlight-color); 
            }
            55% {
                
                transform: translateX(-50%);
                opacity: 1;
                text-shadow: -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000, 2px 2px 0 #000, 0 0 15px rgba(0,0,0,0.8);
            }
            85% {
                transform: translateX(-50%);
                opacity: 1;
            }
            100% {
                transform: translateX(150vw);
                opacity: 0;
            }
        }
        #foreshadow-layer {
    width: 100%;
    height: 100%;
    max-width: 90vw;
    max-height: 90vh;
    aspect-ratio: 1 / 1;
}

.foreshadow-line {
    stroke-width: 3;
    stroke: rgba(239, 68, 68, 0.7); 
    stroke-dasharray: 8 4; 
    animation: dash-flow 1s linear infinite;
}

@keyframes dash-flow {
    to {
        stroke-dashoffset: -12;
    }
}
.cell.drag-over {
    background-color: rgba(212, 183, 131, 0.3) !important;
    outline: 2px solid var(--accent-primary);
    outline-offset: -2px;
}

.combat-text {
    position: fixed; 
    font-size: 1.5rem;
    font-weight: bold;
    font-family: 'Cinzel', serif;
    pointer-events: none;
    z-index: 110; 
    text-shadow: 0 0 5px black, 0 0 5px black;
    animation: float-up-and-fade 1.5s ease-out forwards;
}

.combat-text.damage {
    color: #F87171; 
}

.combat-text.heal {
    color: #4ADE80; 
}

@keyframes float-up-and-fade {
    0% {
        transform: translate(-50%, -50%);
        opacity: 1;
    }
    100% {
        transform: translate(-50%, -150%); 
        opacity: 0;
    }
}

    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4 overflow-x-hidden pt-60">
    <div id="drag-ghost" class="hidden absolute rounded-full z-[100] pointer-events-none w-16 h-16 border-2 border-dashed border-yellow-400 bg-black/30 backdrop-blur-sm"></div>
    <div id="turn-announcement-backdrop"></div> <div id="turn-announcement"></div>

     
    <div id="turn-announcement-backdrop"></div> <div id="turn-announcement"></div>
<div id="utility-controls">
    <button id="login-status-btn" class="info-button p-3 rounded-full transition-transform hover:scale-110 hidden">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.653-.122-1.28-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.653.122-1.28.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"></path></svg>
    </button>
    <button id="user-info-btn" class="info-button p-3 rounded-full transition-transform hover:scale-110">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
        </button>
        <button id="theme-toggle-btn" class="info-button p-3 rounded-full transition-transform hover:scale-110">
            <svg id="theme-icon-sun" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg>
            <svg id="theme-icon-moon" class="w-6 h-6 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path></svg>
        </button>
        <button id="admin-panel-btn" class="text-white font-bold p-3 rounded-full shadow-lg z-50 transition-transform hover:scale-110" style="background-color: var(--accent-primary); color: var(--bg-primary) !important;">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
        </button>
</div>

<div id="login-status-modal" class="modal-backdrop fixed inset-0 flex items-center justify-center p-4 z-[80] hidden">
    <div class="modal-content rounded-md shadow-2xl p-8 w-full max-w-md">
        <h3 class="text-2xl font-bold mb-4 font-title" style="color: var(--accent-primary);">플레이어 접속 현황</h3>
        <ul id="login-status-list-modal" class="space-y-2 text-sm max-h-60 overflow-y-auto pr-2">
            </ul>
        <button id="close-login-status-modal-btn" class="w-full mt-6 bg-gray-600 hover:bg-gray-700 text-white font-bold py-2">닫기</button>
    </div>
</div>
    <div id="user-info-modal" class="modal-backdrop fixed inset-0 flex items-center justify-center p-4 z-[80] hidden">
        <div class="modal-content rounded-md shadow-2xl p-8 w-full max-w-md">
            <h3 class="text-2xl font-bold mb-4 font-title" style="color: var(--accent-primary);">내 정보 및 게임 코드</h3>
            
            <div class="mb-4 p-3 border border-border-secondary text-sm rounded-md">
                <p class="font-semibold text-gray-400 mb-1">게임 코드:</p>
                <div class="flex items-center gap-2">
                    <input readonly id="user-info-game-id-display" class="form-input text-center text-sm p-1 flex-grow" style="background-color: var(--bg-game-id);">
                    <button id="user-info-copy-btn" class="p-2 bg-gray-600 hover:bg-gray-500 rounded-md">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                    </button>
                </div>
            </div>

            <div class="mb-4 p-3 border border-border-secondary text-sm rounded-md">
                <p class="font-semibold text-gray-400 mb-1">현재 인증:</p>
                <span id="user-info-auth-char" class="font-bold text-lg" style="color: var(--accent-primary);">비로그인</span>
                <p class="text-xs text-gray-500 mt-1">로그인하여 캐릭터 제어 권한을 얻으세요.</p>
                <div class="mt-3 flex gap-2">
                    <button id="user-info-login-btn" class="text-sm bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 flex-grow hidden">캐릭터 로그인</button>
                    <button id="user-info-logout-btn" class="text-sm bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 flex-grow hidden">로그아웃</button>
                </div>
            </div>

            <button id="close-user-info-modal-btn" class="w-full mt-4 bg-gray-600 hover:bg-gray-700 text-white font-bold py-2">닫기</button>
        </div>
    </div>
     

     
    <div id="game-lobby-modal" class="modal-backdrop fixed inset-0 flex items-center justify-center p-4 z-[100]">
        <div class="modal-content rounded-md shadow-2xl p-8 w-full max-w-md">
            <h2 class="text-3xl font-bold mb-6 text-center" style="color: var(--accent-primary);">게임 참가</h2>
            <p class="text-center mb-6" style="color: var(--text-secondary);">새 게임을 만들거나, 친구에게 받은 코드를 입력하여 참가하세요.</p>
            <div class="space-y-4">
                <button id="create-game-btn" class="w-full bg-green-600 text-black font-bold py-3 px-4 transition-transform hover:scale-105">새 게임 만들기</button>
                <div class="flex items-center"><hr class="flex-grow border-gray-600"><span class="px-4 text-gray-400">또는</span><hr class="flex-grow border-gray-600"></div>
                <div class="flex gap-2">
                    <input type="text" id="game-id-input" placeholder="게임 코드 입력" class="form-input flex-grow">
                    <button id="join-game-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4">참가하기</button>
                </div>
            </div>
        </div>
    </div>

     
    <div id="pc-login-modal" class="modal-backdrop fixed inset-0 flex items-center justify-center p-4 z-[90] hidden">
        <div class="modal-content rounded-md shadow-2xl p-8 w-full max-w-sm">
            <h3 class="text-xl font-bold mb-4 font-title" style="color: var(--accent-primary);">캐릭터 로그인</h3>
            <p class="mb-4 text-gray-400">제어할 캐릭터 이름과 초기 비밀번호(1234)를 입력하세요.</p>
            <select id="char-login-name-select" class="form-input mb-4"></select>
            <input type="password" id="char-login-password-input" class="form-input text-center" placeholder="비밀번호 (초기: 1234)">
            <p id="char-login-error" class="text-red-500 text-sm mt-2 h-4"></p>
            <div class="flex justify-end gap-4 mt-6">
                <button id="cancel-char-login-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4">취소</button>
                <button id="submit-char-login-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4">확인</button>
            </div>
        </div>
    </div>
    
     
    <div id="character-selection-overlay" class="flex flex-col justify-start fixed top-0 left-0 w-full z-40">
        <div id="selection-list-wrapper" class="overflow-hidden h-full flex items-center transition-opacity duration-300 ease-in-out">
            <div id="selection-list" class="flex mx-auto p-4 gap-4 max-w-7xl w-full overflow-x-auto whitespace-nowrap justify-start">
                 <div class="text-white/70 text-lg w-full text-center p-4">인증 중...</div>
            </div>
        </div>
         
        <button id="overlay-toggle" class="absolute top-full right-4 transform bg-gray-700/90 hover:bg-gray-600/90 text-white p-2 rounded-b-lg z-50 transition-colors shadow-lg">
             <svg id="toggle-icon" class="w-5 h-5 transition-transform duration-300" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7"></path></svg>
        </button>
    </div>
    
     
    <div class="w-full max-w-7xl mx-auto flex flex-col lg:flex-row gap-8">
         
         <div class="panel lg:w-1/4 w-full p-6 shadow-lg flex flex-col">
            <div>
                <div class="flex justify-between items-center mb-2">
                    <h1 class="text-xl font-bold font-title" style="color: var(--accent-primary);">게임 상태</h1>
                </div>
                
                <div id="unit-summary" class="mb-4">
                    <div id="remaining-pc" class="text-center">
                        <p class="text-xs text-gray-400">남은 아군</p>
                        <span id="pc-count" class="summary-count">0</span>
                    </div>
                    <div id="remaining-enemy" class="text-center">
                        <p class="text-xs text-gray-400">남은 적군</p>
                        <span id="enemy-count" class="summary-count">0</span>
                    </div>
                </div>

                <div id="game-id-container" class="hidden">
                    <p class="text-xs font-semibold" style="color: var(--text-secondary);">게임 코드:</p>
                    <div class="flex items-center gap-2 mt-1">
                        <input readonly id="game-id-display" class="form-input text-center text-sm p-1" style="background-color: var(--bg-game-id);">
                        <button id="copy-game-id-btn" class="p-2 bg-gray-600 hover:bg-gray-500">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                        </button>
                    </div>
                </div>
                <div id="auth-status" class="hidden">
                    <p class="font-semibold text-gray-400">현재 인증:</p>
                    <span id="current-auth-char" class="text-yellow-400 font-bold">비로그인</span>
                    <button id="login-btn" class="text-xs ml-2 text-indigo-500 hover:text-indigo-300 hidden">로그인</button>
                    <button id="logout-btn" class="text-xs ml-2 text-red-500 hover:text-red-300 hidden">로그아웃</button>
                </div>
                <div id="turn-status" class="mb-4 stylish-turn-box" >
                    <p class="text-sm font-semibold" style="color: var(--accent-primary);">현재 턴:</p>
                    <div id="current-turn-char" class="text-xl font-bold font-title" style="color: var(--accent-secondary);">준비 중...</div>
                </div>
                 <div id="admin-turn-controls" class="mt-2"></div>
                <div id="skill-controls" class="mt-4 pb-4 border-b border-border-secondary">
                     <p class="text-sm" style="color: var(--text-tertiary);">캐릭터를 선택하면 스킬이 표시됩니다.</p>
                </div>
                <div id="character-list" class="mt-4 flex-grow">
					<div id="char-list-header" class="flex justify-between items-center pb-2 mb-2 border-b border-border-secondary cursor-pointer lg:cursor-default">
						<h2 class="text-lg font-bold font-title" style="color: var(--text-secondary);">캐릭터 상태</h2>
						<svg id="char-list-toggle-icon" class="w-5 h-5 transition-transform lg:hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24">
							<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
						</svg>
					</div>
					<div id="char-list-content" class="max-h-96 overflow-y-auto space-y-2 hidden lg:block">
						<p style="color: var(--text-tertiary);" class="text-sm">게임에 참여해주세요...</p>
					</div>
				</div>
			</div>

			<div class="mt-auto pt-4">
				<button id="leave-game-btn" class="w-full bg-red-600 font-bold py-2 px-4">게임 나가기</button>
			</div>
        </div>

         
        <div class="lg:w-2/4 w-full flex items-center justify-center relative">
    <div id="game-board" class="shadow-inner"></div>
    <svg id="foreshadow-layer" class="absolute top-0 left-0 w-full h-full pointer-events-none z-30"></svg>
</div>

         
        <div id="log-panel" class="panel lg:w-1/4 w-full p-6 shadow-lg">
             <h2 class="text-lg font-bold pb-2 mb-4 font-title" style="color: var(--text-secondary); border-bottom: 1px solid var(--border-secondary);">게임 로그</h2>
             <ul id="game-log-list" class="h-[75vh] overflow-y-auto space-y-2 text-sm pr-2">
                <li class="log-system">게임 로그를 기다리는 중...</li>
             </ul>
        </div>
    </div>

     
    <div id="profile-modal" class="modal-backdrop fixed inset-0 flex items-center justify-center p-4 z-50 hidden"><div id="modal-content" class="w-full max-w-[900px]"></div></div>
    <div id="custom-modal" class="modal-backdrop fixed inset-0 flex items-center justify-center p-4 z-50 hidden"><div id="custom-modal-content" class="modal-content rounded-md shadow-2xl p-8 w-full max-w-sm"><h3 id="custom-modal-title" class="text-xl font-bold mb-4 font-title"></h3><p id="custom-modal-message" class="mb-6"></p><div id="custom-modal-buttons" class="flex justify-end gap-4"></div></div></div>
    <div id="admin-modal" class="modal-backdrop fixed inset-0 flex items-center justify-center p-4 z-[60] hidden"><div id="admin-modal-content" class="modal-content rounded-md shadow-2xl p-8 w-full max-w-3xl max-h-[90vh] overflow-y-auto"><div class="flex justify-between items-center mb-6"><h3 class="text-2xl font-bold font-title" style="color: var(--accent-primary);">관리자 패널</h3><button id="close-admin-modal-btn" class="hover:text-white text-3xl leading-none">&times;</button></div><div id="admin-skill-list" class="space-y-4"></div></div></div>
    <div id="admin-password-modal" class="modal-backdrop fixed inset-0 flex items-center justify-center p-4 z-[70] hidden">
        <div class="modal-content rounded-md shadow-2xl p-8 w-full max-w-sm">
            <h3 class="text-xl font-bold mb-4 font-title">관리자 인증</h3>
            <p class="mb-4 text-gray-400">관리자 비밀번호를 입력하세요.</p>
            <input type="password" id="admin-password-input" class="form-input text-center">
            <p id="admin-password-error" class="text-red-500 text-sm mt-2 h-4"></p>
            <div class="flex justify-end gap-4 mt-6">
                <button id="cancel-admin-login-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4">취소</button>
                <button id="submit-admin-login-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4">확인</button>
            </div>
        </div>
    </div>
    
     
    <div id="map-edit-modal" class="modal-backdrop fixed inset-0 flex items-center justify-center p-4 z-[65] hidden">
        <div class="modal-content rounded-md shadow-2xl p-8 w-full max-w-lg max-h-[90vh] overflow-y-auto">
             
            <div class="flex justify-between items-center mb-6">
                <h3 class="text-2xl font-bold font-title" style="color: var(--accent-primary);">맵 편집 모드 (관리자)</h3>
                <button id="close-map-edit-modal-btn" class="hover:text-white text-3xl leading-none">&times;</button>
            </div>
             
            <p class="mb-4 text-gray-400">보드 칸을 클릭하여 지형을 설정하세요. 준비 단계에서만 작동합니다.</p>
            <div class="space-y-4">
                <div class="flex gap-4 p-4 border border-gray-700 rounded-md">
                    <button data-tile-type="normal" class="tile-select-btn flex-grow p-3 bg-gray-600 hover:bg-gray-500 text-white">일반 칸</button>
                    <button data-tile-type="obstacle" class="tile-select-btn flex-grow p-3 bg-gray-700 hover:bg-gray-600 text-white tile-obstacle">장애물 (이동 불가) 🚫</button>
                    <button data-tile-type="damage" class="tile-select-btn flex-grow p-3 bg-red-800 hover:bg-red-700 text-white tile-damage">대미지 칸 (턴 시작 시 $10$ 피해) 🩸</button>
                </div>
                <div id="map-edit-status" class="text-center font-bold text-lg text-green-400">현재 선택: 일반 칸</div>
                <button id="exit-map-edit-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3">맵 편집 종료</button>
            </div>
        </div>
    </div>


<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
    import { getFirestore, collection, onSnapshot, doc, updateDoc, query, getDocs, writeBatch, getDoc, setDoc, addDoc, serverTimestamp, orderBy, deleteDoc, deleteField } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

    // IMPORTANT: In a real environment, these configs should be loaded securely.

    const firebaseConfig = {
        apiKey: "AIzaSyB_N5qNuqFoK1U166UjwZUs2qaAkW2z3jo",
  authDomain: "test-1f91e.firebaseapp.com",
  projectId: "test-1f91e",
  storageBucket: "test-1f91e.firebasestorage.app",
  messagingSenderId: "885528883532",
  appId: "1:885528883532:web:b8e5536f3020c9c87ddfe9",
  measurementId: "G-08HJHNE3GW"
};

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    // --- Global Variables ---
    const BOARD_SIZE = 10;
    let characters = [];
    let selectedCharacterId = null;
    let foreshadowingAction = null;
    let userId = null;
    let gameId = null; 
    let unsubscribeChars = null;
    let unsubscribeSettings = null;
    let unsubscribeLogs = null;
    let unsubscribeCombatEvents = null;
const combatTextStartTime = new Date();
    let previousTurnCharId = null; 
    let isBoardInitialized = false; 
    let selectedSkill = null; 
    let currentTurnIndex = 0;
    let turnPhase = 'MOVE';
    let isProcessingTurn = false;
    let preMovePosition = null; 
    let gameState = 'PREPARATION';
    let roundPhase = 'PLAYER_PHASE'; 
    let adminSelectedEnemyId = null;
    let selectedCharActionPhase = 'MOVE';
    let currentlyActingEnemyId = null;
    let actingEnemyId = null; 
    let adminForeshadowSkillId = null; 
    let previewCharacterId = null; 
    let round = 1;
    let maxRounds = 0;
    
    let loggedInCharId = null; 
    let isAdmin = false;       
    let isAdminMoveAllowed = true; 
    const DEFAULT_PC_PASSWORD = "1234";
    const PREDEFINED_EFFECTS = {
    rooted: { id: 'rooted', name: '속박'},
    stunned: { id: 'stunned', name: '행동 불가' },
    poisoned: { id: 'poisoned', name: '중독', effectType: 'damage' },
    strengthUp: { id: 'strengthUp', name: '공격력 강화', value: 1.5 },
    strengthDown: { id: 'strengthDown', name: '공격력 약화', value: 0.5 },
    regenerating: { id: 'regenerating', name: '재생', effectType: 'heal' },
    defenseUp: { id: 'defenseUp', name: '방어력 강화', value: 1.5 },
    defenseDown: { id: 'defenseDown', name: '방어력 약화', value: 0.5 }
};

    const STATUS_EFFECT_ICONS = {
    rooted: '🔗',
    stunned: '💫',
    poisoned: '☠️',        
    regenerating: '🌿',   
    strengthUp: '💪',     
    strengthDown: '👎',   
    defenseUp: '🛡️',      
    defenseDown: '🛡️‍🩹'   
};
    
    // NEW: Map/Board State Variables
    let boardTiles = {}; // Stores map features { "x,y": { type: 'obstacle' | 'damage' | 'normal', data: {} } }
    let isMapEditMode = false; // Flag for admin map editing
    let currentTileType = 'normal'; // The tile type the admin is currently placing
    let boardBackgroundImage = ''; // NEW: Background image URL
    let pageBackgroundImage = ''; 
    const DAMAGE_TILE_DAMAGE = 10;
    const MP_REGEN_PER_TURN = 10; // New: Mana regeneration per turn

    const DEFAULT_SKILLS = {
        'move': { id: 'move', name: '이동', type: 'Utility', range: 1, rangeShape: 'diamond', multiplier: 0, icon: '🏃', mpCost: 0, category: 'Utility' }, // 기본 이동 거리를 1로 설정
        'slash': { id: 'slash', name: '베기', type: 'Melee', range: 1, rangeShape: 'diamond', multiplier: 1.5, icon: '⚔️', mpCost: 5, category: 'Attack' },
        'stomp': { id: 'stomp', name: '발 구르기', type: 'Melee', range: 1, rangeShape: 'square', multiplier: 1.2, icon: '💥', mpCost: 8, category: 'Attack'},
        'crosscut': { id: 'crosscut', name: '십자 베기', type: 'Melee', range: 2, rangeShape: 'cross', multiplier: 1.0, icon: '十', mpCost: 10, category: 'Attack'},
        'binding_chains': { id: 'binding_chains', name: '속박의 사슬', type: 'Melee', range: 1, rangeShape: 'square', multiplier: 1.0, icon: '🔗', mpCost: 20, category: 'Attack', appliesEffect: { id: 'stunned', turns: 1 }},
        'poison': { 
            id: 'poison', 
            name: '중독', 
            type: 'Melee', 
            range: 1, 
            rangeShape: 'diamond', 
            multiplier: 0.5, // 초기 피해는 약하게 설정
            icon: '☠️', 
            mpCost: 15, 
            category: 'Attack',
            // 3턴 동안 턴마다 10의 피해를 주는 효과
            appliesEffect: { id: 'poisoned', turns: 3, value: 10 } 
        },
        'shoot': { id: 'shoot', name: '사격', type: 'Ranged', range: 4, rangeShape: 'diamond', multiplier: 1.0, icon: '🏹', mpCost: 5, category: 'Attack' },
        'fireball': { id: 'fireball', name: '화염구', type: 'Ranged', range: 3, rangeShape: 'square', multiplier: 1.0, icon: '🔥', isAoe: true, aoeRange: 1, aoeShape: 'square', mpCost: 15, category: 'Attack' },
        'heal': { id: 'heal', name: '치유의 빛', type: 'Heal', range: 2, rangeShape: 'diamond', multiplier: 1.0, icon: '✨', targetType: 'ALLY', mpCost: 10, category: 'Support' },
        
        // NEW SKILLS
        'resurrect': { id: 'resurrect', name: '부활의 주문', type: 'Heal', range: 1, rangeShape: 'diamond', multiplier: 0.3, icon: '👼', targetType: 'ALLY_DEAD', mpCost: 50, category: 'Support' }, // HP 30% 부활, MP 0으로
        'hp_transfer': { id: 'hp_transfer', name: '생명력 전달', type: 'Heal', range: 2, rangeShape: 'diamond', multiplier: 1.5, icon: '💖', targetType: 'ALLY', mpCost: 0, hpCost: 20, category: 'Support' }, // HP 20 소모, 30 회복
        'mp_transfer': { id: 'mp_transfer', name: '마나 전달', type: 'Support', range: 2, rangeShape: 'diamond', multiplier: 30, icon: '💧', targetType: 'ALLY', mpCost: 10, category: 'Support' }, // MP 10 소모, 30 MP 전달
    };
    let SKILLS = {};
    
    // 스킬 카테고리 순서 정의
    const SKILL_CATEGORIES = ['Attack', 'Support', 'Heal', 'Utility', 'Defense', 'Other'];


    // --- UI Elements ---
    const gameBoard = document.getElementById('game-board');
    const profileModal = document.getElementById('profile-modal');
    const skillControls = document.getElementById('skill-controls');
    const turnStatus = document.getElementById('current-turn-char');
    const lobbyModal = document.getElementById('game-lobby-modal');
    const pcLoginModal = document.getElementById('pc-login-modal');
    const createGameBtn = document.getElementById('create-game-btn');
    const joinGameBtn = document.getElementById('join-game-btn');
    const gameIdInput = document.getElementById('game-id-input');
    const gameIdContainer = document.getElementById('game-id-container');
    const gameIdDisplay = document.getElementById('game-id-display');
    const copyGameIdBtn = document.getElementById('copy-game-id-btn');
    const adminModal = document.getElementById('admin-modal');
    const adminPasswordModal = document.getElementById('admin-password-modal');
    const leaveGameBtn = document.getElementById('leave-game-btn');
    const currentAuthChar = document.getElementById('current-auth-char');
    const logoutBtn = document.getElementById('logout-btn');
    const loginBtn = document.getElementById('login-btn');
    const mapEditModal = document.getElementById('map-edit-modal'); // NEW map edit modal
    const userInfoBtn = document.getElementById('user-info-btn');
    const userInfoModal = document.getElementById('user-info-modal');
    const loginStatusBtn = document.getElementById('login-status-btn');
const loginStatusModal = document.getElementById('login-status-modal');


    // --- Game Lobby ---
    function generateGameId() { return Math.random().toString(36).substring(2, 8).toUpperCase(); }

    async function deleteLogsCollection(gameId) {
        if (!gameId) return;
        try {
            const logsRef = collection(db, "games", gameId, "logs");
            const snapshot = await getDocs(logsRef);
            if (!snapshot.empty) {
                const batch = writeBatch(db);
                snapshot.docs.forEach(doc => {
                    batch.delete(doc.ref);
                });
                await batch.commit();
                console.log(`Logs cleared for game: ${gameId}`);
            }
        } catch (error) {
            console.error("Error clearing logs:", error);
        }
    }

    async function createGame() { await joinGame(generateGameId(), true); }
    async function joinGame(id, isNewGame = false) {
    if (!id || id.trim().length === 0) { showCustomModal("오류", "유효한 게임 코드를 입력해주세요.", [{ text: "확인", class: "bg-red-600" }]); return; }
    gameId = id.trim().toUpperCase();

    if (!isNewGame) {
        const docSnap = await getDoc(doc(db, "games", gameId));
        if (!docSnap.exists()) { showCustomModal("참가 실패", "존재하지 않는 게임 코드입니다.", [{ text: "확인", class: "bg-red-600" }]); gameId = null; return; }
    }

    localStorage.setItem('currentGameId', gameId);
    lobbyModal.classList.add('hidden');
    gameIdDisplay.value = gameId;

    if (isNewGame) {
        await deleteLogsCollection(gameId);
        await seedInitialSettings(gameId);
        await seedInitialCharacters(gameId);
        await setDoc(doc(db, 'games', gameId, 'board', 'tiles'), { tiles: {} });
        await logAction("⚔️ 새로운 게임이 시작되었습니다! 게임 로그가 초기화되었습니다.", "system");
    }
    
    listenForGameData(gameId);
    listenForCombatTextEvents(gameId); 
    
    openPCLoginModal();
}
    function leaveGame() { localStorage.removeItem('currentGameId', gameId); location.reload(); }

    // --- Authentication ---
    onAuthStateChanged(auth, (user) => {
        if (user) {
            userId = user.uid;
            const savedGameId = localStorage.getItem('currentGameId');
            if (savedGameId) { joinGame(savedGameId); } 
            else { lobbyModal.classList.remove('hidden'); }
        } else { signInAnonymously(auth).catch((error) => console.error("Anonymous sign-in failed:", error)); }
    });
    
    // --- Data Seeding ---
    async function seedInitialSettings(gameId) { 
        await setDoc(doc(db, 'games', gameId), { 
            skills: DEFAULT_SKILLS, 
            currentTurnIndex: 0, 
            currentTurnCharId: null, 

            adminPassword: "7251", 
            gameState: 'PREPARATION', 
            round: 1, 
            maxRounds: 0, 
            isAdminMoveAllowed: true,
            boardBackgroundImage: '', // Default empty background
            pageBackgroundImage: ''
        }); 
    }
    async function seedInitialCharacters(gameId) {
    const charCollectionRef = collection(db, "games", gameId, "characters");
    const snapshot = await getDocs(charCollectionRef);
    if (snapshot.empty) {
        const batch = writeBatch(db);
        const pcData = [ 
            { name: "User1", img: "", type: 'PC', size: 1, skills: ['slash', 'shoot', 'heal', 'hp_transfer'], order: 1 },
            { name: "User2", img: "", type: 'PC', size: 1, skills: ['crosscut', 'resurrect', 'mp_transfer'], order: 3 },
        ];
        const enemyData = [ 
            { name: "Enemy1", img: "", type: 'ENEMY', size: 1, skills: ['slash'], order: 2 }, 
            { name: "Enemy2", img: "", type: 'ENEMY', size: 2, skills: ['stomp'], order: 4 }, 
        ];
        [...pcData, ...enemyData].forEach(char => {
            const charPassword = char.type === 'PC' ? DEFAULT_PC_PASSWORD : ''; 
            const newChar = { 
                name: char.name, imageUrl: char.img || '', type: char.type, size: char.size, 
                hp: 100, maxHp: 100, mp: 50, maxMp: 50, 
                minAttack: 12, maxAttack: 18, minDefense: 3, maxDefense: 7, 
                x: null, y: null, skills: char.skills || [], turnOrder: char.order, 
                password: charPassword, isAuto: false, statusEffects: [],
                isLoggedIn: false // [추가] 로그인 상태 필드 추가
            };
            batch.set(doc(charCollectionRef), newChar);
        });
        await batch.commit();
    }
}
    
    // --- Data Listeners ---
    function listenForGameData(gameId) {
    if (unsubscribeSettings) unsubscribeSettings();
    if (unsubscribeChars) unsubscribeChars();
    if (unsubscribeLogs) unsubscribeLogs();

    unsubscribeSettings = onSnapshot(doc(db, 'games', gameId), async (docSnap) => { // async 추가
        if (docSnap.exists()) {
            const data = docSnap.data();
            const oldGameState = gameState; // [수정] 이전 gameState를 기억합니다.
            const oldRoundPhase = roundPhase;

            SKILLS = data.skills || {};
            gameState = data.gameState || 'PREPARATION';
            roundPhase = data.roundPhase || 'PLAYER_PHASE';

            if (oldGameState === 'STARTED' && gameState === 'ENDED' && data.gameResult) {
                showGameSummaryModal(data.gameResult.title, data.gameResult.message);
            }

            if (oldGameState === 'PREPARATION' && gameState === 'STARTED') {
                showBannerAnnouncement("FIGHT!", "게임 시작", '2rem', '4rem');
            }
            round = data.round || 1;
            maxRounds = data.maxRounds || 0;
            isAdminMoveAllowed = data.isAdminMoveAllowed !== undefined ? data.isAdminMoveAllowed : true;
            
            foreshadowingAction = data.foreshadowingAction || null;
            
            boardBackgroundImage = data.boardBackgroundImage || '';
            pageBackgroundImage = data.pageBackgroundImage || '';
            document.body.style.setProperty('--page-background-image', pageBackgroundImage ? `url('${pageBackgroundImage}')` : 'none');

            const turnCharId = data.currentTurnCharId;
            actingEnemyId = data.actingEnemyId || null;

            if (gameState === 'STARTED' && oldRoundPhase !== roundPhase) {
                selectedCharacterId = null;
                previewCharacterId = null;
                selectedSkill = null;
                adminSelectedEnemyId = null;

                switch (roundPhase) {
                    case 'ENEMY_FORESHADOW':
                        showBannerAnnouncement(`Round ${round}`, "적 행동 예고");
                        if (isAdmin) {
                            determineEnemyNextActions();
                        }
                        break;
                    
                    case 'PLAYER_PHASE': { 
                        showBannerAnnouncement(`Round ${round}`, "아군 턴 시작");
                        if (isAdmin) {
                            const livingPCs = characters.filter(c => c.type === 'PC' && c.hp > 0 && c.x !== null);
                            if (livingPCs.length > 0) {
                                const batch = writeBatch(db);
                                let mpWasRecovered = false;
                                
                                for (const pc of livingPCs) {
                                    const charRef = doc(db, 'games', gameId, 'characters', pc.id);
                                    let updates = {};
                                    const newMp = Math.min(pc.maxMp, pc.mp + MP_REGEN_PER_TURN);
                                    if (newMp > pc.mp) {
                                        updates.mp = newMp;
                                        mpWasRecovered = true;
                                    }
                                    const tileKey = `${pc.x},${pc.y}`;
                const tile = boardTiles[tileKey];
                if (tile && tile.type === 'damage') {
                    const damage = DAMAGE_TILE_DAMAGE;
                    updates.hp = Math.max(0, (updates.hp !== undefined ? updates.hp : pc.hp) - damage);
                    logAction(`🩸 ${pc.name}이(가) 대미지 칸에 서있어 **${damage} 피해**를 입었습니다!`, "damage");
                }
                                    const effects = pc.statusEffects || [];
                                    if (effects.length > 0) {
                                        const isStunned = effects.some(effect => effect.id === 'stunned');
                                        if (isStunned) {
                                            logAction(`💫 ${pc.name}은(는) [행동 불가] 상태이므로 턴이 자동으로 넘어갑니다.`, "system");
                                            updates.hasActedThisRound = true;
                                        }
                                        let finalHp = pc.hp;
                                        let hpChanged = false;
                                        effects.forEach(effect => {
                                            if (effect.effectType === 'heal') {
                                                const healAmount = effect.value || 15;
                                                finalHp = Math.min(pc.maxHp, finalHp + healAmount);
                                                hpChanged = true;
                                                logAction(`🌿 ${pc.name}이(가) [${effect.name}] 효과로 **${healAmount} HP**를 회복했습니다!`, "heal");
                                            } else if (effect.effectType === 'damage') {
                                                const damageAmount = effect.value || 10;
                                                finalHp = Math.max(0, finalHp - damageAmount);
                                                hpChanged = true;
                                                logAction(`☠️ ${pc.name}이(가) [${effect.name}] 효과로 **${damageAmount} 피해**를 입었습니다!`, "damage");
                                            }
                                        });
                                        if (hpChanged) {
                                            updates.hp = finalHp;
                                        }
                                    }
                                    if (Object.keys(updates).length > 0) {
                                        batch.update(charRef, updates);
                                    }
                                }
                                await batch.commit();
                                if (mpWasRecovered) {
                                        await logAction(`💧 모든 아군이 ${MP_REGEN_PER_TURN}의 MP를 회복했습니다.`, "system");
                                }
                            }
                        }
                        break;
                    }
                    
                    case 'ENEMY_EXECUTION': { 
                        showBannerAnnouncement(`Round ${round}`, "적군 턴 시작");
                        if (isAdmin) {
                            const livingEnemies = characters.filter(c => c.type === 'ENEMY' && c.hp > 0 && c.x !== null);
                            if (livingEnemies.length > 0) {
                                const batch = writeBatch(db);
                                let mpWasRecovered = false;
                                for (const enemy of livingEnemies) {
                                    const charRef = doc(db, 'games', gameId, 'characters', enemy.id);
                                    let updates = {};
                                    const newMp = Math.min(enemy.maxMp, enemy.mp + MP_REGEN_PER_TURN);
                                    if (newMp > enemy.mp) {
                                        updates.mp = newMp;
                                        mpWasRecovered = true;
                                    }
                                    const tileKey = `${enemy.x},${enemy.y}`;
                const tile = boardTiles[tileKey];
                if (tile && tile.type === 'damage') {
                    const damage = DAMAGE_TILE_DAMAGE;
                    updates.hp = Math.max(0, enemy.hp - damage);
                    logAction(`🩸 ${enemy.name}이(가) 대미지 칸에 서있어 **${damage} 피해**를 입었습니다!`, "damage");
                }
                                    const effects = enemy.statusEffects || [];
                                    if (effects.length > 0) {
                                        let finalHp = enemy.hp;
                                        let hpChanged = false;
                                        effects.forEach(effect => {
                                            if (effect.effectType === 'heal') {
                                                const healAmount = effect.value || 15;
                                                finalHp = Math.min(enemy.maxHp, finalHp + healAmount);
                                                hpChanged = true;
                                                logAction(`🌿 ${enemy.name}이(가) [${effect.name}] 효과로 **${healAmount} HP**를 회복했습니다!`, "heal");
                                            } else if (effect.effectType === 'damage') {
                                                const damageAmount = effect.value || 10;
                                                finalHp = Math.max(0, finalHp - damageAmount);
                                                hpChanged = true;
                                                logAction(`☠️ ${enemy.name}이(가) [${effect.name}] 효과로 **${damageAmount} 피해**를 입었습니다!`, "damage");
                                            }
                                        });
                                        if (hpChanged) {
                                            updates.hp = finalHp;
                                        }
                                    }
                                    if (Object.keys(updates).length > 0) {
                                        batch.update(charRef, updates);
                                    }
                                } 
                                await batch.commit();
                                if (mpWasRecovered) {
                                    await logAction(`💧 모든 적군이 ${MP_REGEN_PER_TURN}의 MP를 회복했습니다.`, "system");
                                }
                            }
                        }
                        break;
                    } 
                }
            }
            
            const currentTurnChar = characters.find(c => c.id === turnCharId);
            if (gameState === 'STARTED' && currentTurnChar && currentTurnChar.hp <= 0 && isAdmin) {
                setTimeout(() => advanceRoundPhase(), 1000);
            }
            
            if (turnCharId && turnCharId !== previousTurnCharId) {
                if (currentTurnChar && currentTurnChar.isAuto) {
                    setTimeout(() => runAutoTurn(currentTurnChar), 1000);
                }
            }
            previousTurnCharId = turnCharId;
            currentTurnIndex = characters.findIndex(c => c.id === turnCharId);
            if (currentTurnIndex === -1) currentTurnIndex = 0;
            if (!adminModal.classList.contains('hidden')) openAdminModal();

            onSnapshot(doc(db, 'games', gameId, 'board', 'tiles'), (tileDoc) => {
                boardTiles = tileDoc.data()?.tiles || {};
                render();
            });

            render();
        }
    });

    unsubscribeChars = onSnapshot(query(collection(db, "games", gameId, "characters")), (snapshot) => {
        characters = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })).sort((a, b) => a.turnOrder - b.turnOrder);
        characters.forEach(char => {
            if (char.mp === undefined || char.maxMp === undefined) {
                char.mp = char.maxMp = 50; 
            }
        });
        if (!pcLoginModal.classList.contains('hidden')) populatePCLoginSelect(); 
        render();
    });

    unsubscribeLogs = onSnapshot(query(collection(db, "games", gameId, "logs"), orderBy("timestamp", "desc")), (snapshot) => {
        renderLogs(snapshot.docs.map(doc => doc.data()));
    });
}

async function triggerCombatText(character, text, type) {
    if (!gameId || !character) return;
    try {
        await addDoc(collection(db, "games", gameId, "combatEvents"), {
            characterId: character.id,
            text: text,
            type: type,
            timestamp: serverTimestamp()
        });
    } catch (error) {
        console.error("Error triggering combat text:", error);
    }
}

function listenForCombatTextEvents(gameId) {
    if (unsubscribeCombatEvents) unsubscribeCombatEvents();

    const q = query(
        collection(db, "games", gameId, "combatEvents"),
        orderBy("timestamp")
    );

    unsubscribeCombatEvents = onSnapshot(q, (snapshot) => {
        snapshot.docChanges().forEach(async (change) => {
            if (change.type === "added") {
                const eventData = change.doc.data();
                const character = characters.find(c => c.id === eventData.characterId);
                if (character) {
                    showCombatText(character, eventData.text, eventData.type);
                }
                
                try {
                    await deleteDoc(change.doc.ref);
                } catch (error) {
                    console.error("Error deleting combat text event:", error);
                }
            }
        });
    });
}
       const delay = ms => new Promise(res => setTimeout(res, ms));
    async function logAction(message, type = "system") { if (gameId) await addDoc(collection(db, "games", gameId, "logs"), { message, type, timestamp: serverTimestamp() }); }
    async function advanceRoundPhase() {
    if (roundPhase === 'PLAYER_PHASE') {
        await setDoc(doc(db, 'games', gameId), { roundPhase: 'ENEMY_EXECUTION' }, { merge: true });
    } 
    else if (roundPhase === 'ENEMY_EXECUTION') {
        currentlyActingEnemyId = null; 

        const endOfRoundBatch = writeBatch(db);
        const livingCharacters = characters.filter(c => c.hp > 0 && c.x !== null);

        for (const char of livingCharacters) {
            const effects = char.statusEffects || [];
            if (effects.length > 0) {
                const updatedEffects = effects.reduce((acc, effect) => {
                    
                 
                    if (effect.isNew) {
                        const { isNew, ...rest } = effect; 
                        acc.push(rest);
                    } else {
                
                        const newTurnsRemaining = effect.turnsRemaining - 1;
                        if (newTurnsRemaining > 0) {
                            acc.push({ ...effect, turnsRemaining: newTurnsRemaining });
                        } else {
                            logAction(`⏱️ ${char.name}의 [${effect.name}] 효과가 사라졌습니다.`, "system");
                        }
                    }
                

                    return acc;
                }, []);
                const charRef = doc(db, 'games', gameId, 'characters', char.id);
                endOfRoundBatch.update(charRef, { statusEffects: updatedEffects });
            }
        }
        await endOfRoundBatch.commit();
        const newRound = round + 1;

        showBannerAnnouncement(`Round ${newRound}`, "적 행동 예고");

        // DB 상태 업데이트
        await setDoc(doc(db, 'games', gameId), { 
            round: newRound,
            roundPhase: 'ENEMY_FORESHADOW' 
        }, { merge: true });
        
        // 모든 PC의 행동 여부 초기화
        const batch = writeBatch(db);
        characters.filter(c => c.type === 'PC').forEach(pc => {
            const charRef = doc(db, 'games', gameId, 'characters', pc.id);
            batch.update(charRef, { hasActedThisRound: false });
        });
        await batch.commit();
    }
}

async function determineEnemyNextActions() {
    if (!gameId) return;

    const livingEnemies = characters.filter(c => c.type === 'ENEMY' && c.hp > 0 && c.x !== null);
    const livingPCs = characters.filter(c => c.type === 'PC' && c.hp > 0 && c.x !== null);

    if (livingPCs.length === 0 && livingEnemies.length <= 1) {
        console.log("행동할 대상이 없어 적 AI 설정을 건너뜁니다.");
        return;
    }

    const batch = writeBatch(db);

    livingEnemies.forEach(enemy => {
        let decisionMade = false;

        const healSkillId = enemy.skills.find(id => SKILLS[id]?.category === 'Heal');
        
        if (healSkillId) {
            const healSkill = SKILLS[healSkillId];
            const potentialHealTargets = livingEnemies.filter(ally =>
                ally.id !== enemy.id && // 자기 자신은 제외
                ally.hp < ally.maxHp * 0.7 && // 체력이 70% 미만
                getDistance(enemy, ally) <= healSkill.range // 스킬 사거리 내에 있음
            );

            if (potentialHealTargets.length > 0) {
                potentialHealTargets.sort((a, b) => (a.hp / a.maxHp) - (b.hp / b.maxHp));
                const healTarget = potentialHealTargets[0];

                const enemyRef = doc(db, 'games', gameId, 'characters', enemy.id);
                batch.update(enemyRef, {
                    nextAction: {
                        targetId: healTarget.id,
                        skillId: healSkillId
                    }
                });
                decisionMade = true; 
            }
        }
        if (!decisionMade && livingPCs.length > 0) {
            let closestTarget = null;
            let minDistance = Infinity;

            livingPCs.forEach(pc => {
                const distance = getDistance(enemy, pc);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestTarget = pc;
                }
            });

            if (closestTarget) {
                const attackSkillId = enemy.skills.find(id => SKILLS[id]?.category === 'Attack');

                if (attackSkillId) {
                    const enemyRef = doc(db, 'games', gameId, 'characters', enemy.id);
                    batch.update(enemyRef, {
                        nextAction: {
                            targetId: closestTarget.id,
                            skillId: attackSkillId
                        }
                    });
                }
            }
        }
    });

    await batch.commit();
    await logAction("🤖 AI가 모든 적의 행동 계획을 수립했습니다.", "system");
}

async function executeSingleEnemyAction(enemyId) {
    const enemy = characters.find(c => c.id === enemyId);
    if (!enemy || !enemy.nextAction) return;

    currentlyActingEnemyId = enemy.id;
    render();
    await delay(700);

    const target = characters.find(c => c.id === enemy.nextAction.targetId);
    const skill = SKILLS[enemy.nextAction.skillId];

    if (target && target.hp > 0 && skill) {
        let bestMovePos = { x: enemy.x, y: enemy.y };
        const moveRange = enemy.moveRange || SKILLS['move']?.range || 1;
        const attackRange = skill.range;
        
        if (getDistance(enemy, target) > attackRange) {
            let minMoveDistance = Infinity;
            for (let dy = -moveRange; dy <= moveRange; dy++) {
                for (let dx = -moveRange; dx <= moveRange; dx++) {
                    if (Math.abs(dx) + Math.abs(dy) > moveRange) continue;
                    const moveX = enemy.x + dx, moveY = enemy.y + dy;
                    if (!canPlaceCharacter(enemy, moveX, moveY)) continue;
                    
                    const movedPos = { x: moveX, y: moveY };
                    if (getDistance(movedPos, target) <= attackRange) {
                        const moveDistance = Math.abs(dx) + Math.abs(dy);
                        if (moveDistance < minMoveDistance) {
                            minMoveDistance = moveDistance;
                            bestMovePos = movedPos;
                        }
                    }
                }
            }
        }
        
        if (bestMovePos.x !== enemy.x || bestMovePos.y !== enemy.y) {
            await logAction(`🏃 ${enemy.name}이(가) 이동합니다.`, "move");
            await updateDoc(doc(db, 'games', gameId, 'characters', enemy.id), { x: bestMovePos.x, y: bestMovePos.y });
            await delay(1000);
        }

        const updatedEnemy = characters.find(c => c.id === enemy.id);
        const updatedTarget = characters.find(c => c.id === target.id);

        if (updatedTarget && updatedTarget.hp > 0 && getDistance(updatedEnemy, updatedTarget) <= attackRange) {
            await executeSkill(updatedEnemy, updatedTarget, skill.id, false);
            await delay(1000);
        } else {
            await logAction(`...하지만 ${enemy.name}의 공격 범위에 대상이 없습니다!`, "system");
            await delay(500);
        }
    }
    
    await updateDoc(doc(db, 'games', gameId, 'characters', enemy.id), { nextAction: null });
    
    currentlyActingEnemyId = null;
}
    async function executeEnemyActions() {
    await logAction(`🔥 적들이 행동을 개시합니다!`, "system");

    const stunnedEnemies = characters.filter(c => c.type === 'ENEMY' && c.hp > 0 && c.statusEffects?.some(e => e.id === 'stunned'));
    for (const enemy of stunnedEnemies) {
        await logAction(`💫 ${enemy.name}은(는) [행동 불가] 상태이므로 행동하지 못합니다.`, "system");
    }

    const enemiesToAct = characters.filter(c => c.type === 'ENEMY' && c.hp > 0 && c.nextAction && !c.statusEffects?.some(e => e.id === 'stunned'));

    for (const enemy of enemiesToAct) {
        await updateDoc(doc(db, 'games', gameId), { actingEnemyId: enemy.id });
        await delay(700);

        const target = characters.find(c => c.id === enemy.nextAction.targetId);
        const skill = SKILLS[enemy.nextAction.skillId];

        if (!target || !skill) {
            await updateDoc(doc(db, 'games', gameId, 'characters', enemy.id), { nextAction: null });
            continue;
        }

        let bestMovePos = { x: enemy.x, y: enemy.y };
        const moveRange = enemy.moveRange !== undefined ? enemy.moveRange : (SKILLS['move']?.range || 1);
        const attackRange = skill.range;

        const phantomEnemy = { ...enemy };
        if (!isAttackPossible(phantomEnemy, target, attackRange)) {
            let minMoveDistance = Infinity; // 공격하기 위해 움직여야 하는 최소 거리
            let foundAttackSpot = false;

            // 1. 공격 가능한 최적의 위치 탐색
            for (let dy = -moveRange; dy <= moveRange; dy++) {
                for (let dx = -moveRange; dx <= moveRange; dx++) {
                    if (Math.abs(dx) + Math.abs(dy) > moveRange) continue;

                    const moveX = enemy.x + dx;
                    const moveY = enemy.y + dy;

                    if (!canPlaceCharacter(enemy, moveX, moveY)) continue;
                    
                    const phantomAttacker = { ...enemy, x: moveX, y: moveY };
                    if (isAttackPossible(phantomAttacker, target, attackRange)) {
                        foundAttackSpot = true;
                        const moveDistance = Math.abs(dx) + Math.abs(dy);
                        if (moveDistance < minMoveDistance) {
                            minMoveDistance = moveDistance;
                            bestMovePos = { x: moveX, y: moveY };
                        }
                    }
                }
            }

            // 2. 공격 가능한 위치가 없을 경우, 목표를 향해 최대한 이동
            if (!foundAttackSpot) {
                let minTargetDistance = getDistance(enemy, target); // 목표까지의 현재 거리

                for (let dy = -moveRange; dy <= moveRange; dy++) {
                    for (let dx = -moveRange; dx <= moveRange; dx++) {
                        if (Math.abs(dx) + Math.abs(dy) > moveRange) continue;

                        const moveX = enemy.x + dx;
                        const moveY = enemy.y + dy;

                        if (!canPlaceCharacter(enemy, moveX, moveY)) continue;
                        
                        const movedPos = { x: moveX, y: moveY };
                        const targetDistance = getDistance(movedPos, target);
                        
                        if (targetDistance < minTargetDistance) {
                            minTargetDistance = targetDistance;
                            bestMovePos = movedPos;
                        }
                    }
                }
            }
        }
        
        // 최종 결정된 위치로 이동
        if (bestMovePos.x !== enemy.x || bestMovePos.y !== enemy.y) {
            await logAction(`🏃 ${enemy.name}이(가) 이동합니다.`, "move");
            await updateDoc(doc(db, 'games', gameId, 'characters', enemy.id), { x: bestMovePos.x, y: bestMovePos.y });
            await delay(1000);
        }

        const updatedEnemy = characters.find(c => c.id === enemy.id);
        const updatedTarget = characters.find(c => c.id === target.id);

        if (updatedTarget && updatedTarget.hp > 0 && isAttackPossible(updatedEnemy, updatedTarget, attackRange)) {
            await updateDoc(doc(db, 'games', gameId), {
                foreshadowingAction: {
                    charId: updatedEnemy.id,
                    skillId: skill.id
                }
            });
            await delay(1200);

            await executeSkill(updatedEnemy, updatedTarget, skill.id);

            await updateDoc(doc(db, 'games', gameId), {
                foreshadowingAction: null
            });
            await delay(1000);
        } else if (bestMovePos.x !== enemy.x || bestMovePos.y !== enemy.y) {
            // 이동은 했지만 공격은 못한 경우
            await logAction(`...${enemy.name}이(가) ${target.name}을(를) 향해 접근합니다.`, "move");
            await delay(500);
        } else {
            // 이동도, 공격도 못한 경우
            await logAction(`...하지만 ${enemy.name}의 공격 범위에 대상이 없습니다!`, "system");
            await delay(500);
        }
        
        await updateDoc(doc(db, 'games', gameId, 'characters', enemy.id), { nextAction: null });
        await updateDoc(doc(db, 'games', gameId), { actingEnemyId: null });
    }

    logAction("✅ 모든 적의 행동이 종료되었습니다.", "system");
    await delay(500);

    advanceRoundPhase();
}
function showCombatText(character, text, type) {
    if (!character || character.x === null) return;

    const token = document.querySelector(`.character-token[data-char-id="${character.id}"]`);
    if (!token) return;

    const tokenRect = token.getBoundingClientRect();
    
    const textElement = document.createElement('div');
    textElement.classList.add('combat-text', type);
    textElement.textContent = text;

    document.body.appendChild(textElement);
    textElement.style.left = `${tokenRect.left + tokenRect.width / 2}px`;
    textElement.style.top = `${tokenRect.top}px`;

    setTimeout(() => {
        textElement.remove();
    }, 1500);
}

function renderForeshadowing() {
    const svgLayer = document.getElementById('foreshadow-layer');
    const boardRect = gameBoard.getBoundingClientRect();
    const containerRect = gameBoard.parentElement.getBoundingClientRect();

    svgLayer.style.top = `${boardRect.top - containerRect.top}px`;
    svgLayer.style.left = `${boardRect.left - containerRect.left}px`;
    svgLayer.style.width = `${boardRect.width}px`;
    svgLayer.style.height = `${boardRect.height}px`;
    svgLayer.innerHTML = ''; 
    
    document.querySelectorAll('.enemy-threat-range').forEach(cell => cell.classList.remove('enemy-threat-range'));

    const cellWidth = boardRect.width / BOARD_SIZE;
    const cellHeight = boardRect.height / BOARD_SIZE;

    if (gameState !== 'STARTED' || (roundPhase !== 'PLAYER_PHASE' && roundPhase !== 'ENEMY_FORESHADOW')) {
        return;
    }

    characters.forEach(char => {
        if (char.type === 'ENEMY' && char.nextAction && char.hp > 0) {
            const target = characters.find(c => c.id === char.nextAction.targetId);
            if (!target || target.hp <= 0) return;

            // 점선 그리기 로직만 남깁니다.
            const startX = (char.x + char.size / 2) * cellWidth;
            const startY = (char.y + char.size / 2) * cellHeight;
            const endX = (target.x + target.size / 2) * cellWidth;
            const endY = (target.y + target.size / 2) * cellHeight;

            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', startX);
            line.setAttribute('y1', startY);
            line.setAttribute('x2', endX);
            line.setAttribute('y2', endY);
            line.setAttribute('class', 'foreshadow-line');
            svgLayer.appendChild(line);

        }
    });
}

    function showBannerAnnouncement(line1, line2, size1 = '1.5rem', size2 = '3.5rem') {
        const announcementEl = document.getElementById('turn-announcement');
        const backdropEl = document.getElementById('turn-announcement-backdrop');
        if (!announcementEl || !backdropEl) return;

        announcementEl.innerHTML = `
            <span class="round-text" style="font-size: ${size1};">${line1}</span>
            <span class="turn-text" style="font-size: ${size2};">${line2}</span>
        `;

        announcementEl.classList.remove('animate-turn');
        backdropEl.classList.remove('visible');
        void announcementEl.offsetWidth; // Reflow
        announcementEl.classList.add('animate-turn');
        backdropEl.classList.add('visible');

        announcementEl.addEventListener('animationend', () => {
            announcementEl.classList.remove('animate-turn');
            backdropEl.classList.remove('visible');
        }, { once: true });
    }

    function showTurnAnnouncement(characterName, round) {
        showBannerAnnouncement(`Round ${round}`, `${characterName}의 턴입니다`);
    }

    
    // NEW: Function to check for damage tile and apply damage if necessary
    async function checkAndApplyTileDamage(char) {
        if (char.x === null || char.hp <= 0) return;

        const tileKey = `${char.x},${char.y}`;
        const tile = boardTiles[tileKey];

        if (tile && tile.type === 'damage') {
            const damage = DAMAGE_TILE_DAMAGE;
            const newHp = Math.max(0, char.hp - damage);
            
            await updateDoc(doc(db, 'games', gameId, 'characters', char.id), { hp: newHp });

            let message = `🩸 ${char.name}이(가) 대미지 칸에 서있어 **${damage} 피해**를 입었습니다!`;
            if (newHp === 0) message += `<br>💀 ${char.name}이(가) 쓰러졌습니다!`;
            await logAction(message, "damage");
        }
    }

    // 두 지점 사이의 거리를 계산하는 도우미 함수
    function getDistance(pos1, pos2) {
        if (!pos1 || !pos2) return Infinity;
        return Math.abs(pos1.x - pos2.x) + Math.abs(pos1.y - pos2.y);
    }
    // [추가] 두 캐릭터의 크기를 모두 고려하여 실제 공격 가능한지 판단하는 함수
function isAttackPossible(attacker, target, attackRange) {
    if (!attacker || !target) return false;
    const attackerSize = attacker.size || 1;
    const targetSize = target.size || 1;

    // 공격자가 차지하는 모든 칸을 순회
    for (let ax = 0; ax < attackerSize; ax++) {
        for (let ay = 0; ay < attackerSize; ay++) {
            // 대상이 차지하는 모든 칸을 순회
            for (let tx = 0; tx < targetSize; tx++) {
                for (let ty = 0; ty < targetSize; ty++) {
                    const attackerCell = { x: attacker.x + ax, y: attacker.y + ay };
                    const targetCell = { x: target.x + tx, y: target.y + ty };
                    
                    // 두 칸 사이의 거리가 공격 범위 내에 있으면 즉시 true 반환
                    if (getDistance(attackerCell, targetCell) <= attackRange) {
                        return true;
                    }
                }
            }
        }
    }
    // 모든 칸을 확인해도 공격 가능한 경우가 없으면 false 반환
    return false;
}

    // 자동 턴을 실행하는 메인 AI 함수
    async function runAutoTurn(character) {
        await logAction(`🤖 ${character.name}의 자동 턴을 시작합니다.`, "system");

        // 1. 공격할 대상 찾기 (살아있는 적군)
        const targets = characters.filter(c => c.type !== character.type && c.hp > 0 && c.x !== null);
        if (targets.length === 0) {
            await logAction(`🤖 공격할 대상이 없어 ${character.name}이(가) 턴을 종료합니다.`, "system");
            await nextTurn();
            return;
        }

        // 1.1. 가장 가까운 적을 타겟으로 설정
        let closestTarget = null;
        let minDistance = Infinity;
        targets.forEach(target => {
            const distance = getDistance(character, target);
            if (distance < minDistance) {
                minDistance = distance;
                closestTarget = target;
            }
        });

        // 2. 사용할 스킬 선택 (가장 첫 번째 공격 스킬)
        const attackSkillId = character.skills.find(id => SKILLS[id]?.category === 'Attack');
        if (!attackSkillId) {
            await logAction(`🤖 사용할 공격 스킬이 없어 ${character.name}이(가) 턴을 종료합니다.`, "system");
            await nextTurn();
            return;
        }
        const attackSkill = SKILLS[attackSkillId];

        // 3. 이동 및 공격 위치 계산
        const moveRange = character.moveRange || SKILLS['move']?.range || 1;
        const attackRange = attackSkill.range;
        const characterSize = character.size || 1;

        let bestMovePos = { x: character.x, y: character.y };
        let canAttackAfterMove = false;

        // 3.1. 현재 위치에서 공격 가능한지 확인
        const distanceToTarget = getDistance(character, closestTarget);
        if (distanceToTarget <= attackRange) {
            canAttackAfterMove = true;
        } else {
            // 3.2. 이동해서 공격할 최적의 위치 찾기
            let bestAttackSpot = null;
            let minMoveDistance = Infinity;

            // 이동 가능한 모든 칸을 순회
            for (let dy = -moveRange; dy <= moveRange; dy++) {
                for (let dx = -moveRange; dx <= moveRange; dx++) {
                    if (Math.abs(dx) + Math.abs(dy) > moveRange) continue;

                    const moveX = character.x + dx;
                    const moveY = character.y + dy;

                    if (moveX < 0 || moveY < 0 || moveX >= BOARD_SIZE || moveY >= BOARD_SIZE) continue;
                    if (!canPlaceCharacter(character, moveX, moveY)) continue;
                    
                    const movedPos = { x: moveX, y: moveY };
                    const distanceToTargetAfterMove = getDistance(movedPos, closestTarget);

                    // 이동 후 공격이 가능하다면, 해당 위치를 후보로
                    if (distanceToTargetAfterMove <= attackRange) {
                        canAttackAfterMove = true;
                        // 가장 적게 움직이는 위치를 선택
                        const moveDistance = getDistance(character, movedPos);
                        if (moveDistance < minMoveDistance) {
                            minMoveDistance = moveDistance;
                            bestAttackSpot = movedPos;
                        }
                    }
                }
            }
             if (bestAttackSpot) {
                bestMovePos = bestAttackSpot;
            } else {
                let closestPosToTarget = bestMovePos;
                let minDistanceToTarget = getDistance(bestMovePos, closestTarget);

                for (let dy = -moveRange; dy <= moveRange; dy++) {
                    for (let dx = -moveRange; dx <= moveRange; dx++) {
                        if (Math.abs(dx) + Math.abs(dy) > moveRange) continue;

                        const moveX = character.x + dx;
                        const moveY = character.y + dy;
                        if (moveX < 0 || moveY < 0 || moveX >= BOARD_SIZE || moveY >= BOARD_SIZE) continue;
                        if (!canPlaceCharacter(character, moveX, moveY)) continue;

                        const movedPos = { x: moveX, y: moveY };
                        const dist = getDistance(movedPos, closestTarget);
                        if (dist < minDistanceToTarget) {
                            minDistanceToTarget = dist;
                            closestPosToTarget = movedPos;
                        }
                    }
                }
                bestMovePos = closestPosToTarget;
            }
        }
        
        const moved = (bestMovePos.x !== character.x || bestMovePos.y !== character.y);
        if (moved) {
            await logAction(`🤖 ${character.name}이(가) (${bestMovePos.x}, ${bestMovePos.y})(으)로 이동합니다.`, "move");
            await updateDoc(doc(db, 'games', gameId, 'characters', character.id), { x: bestMovePos.x, y: bestMovePos.y });
        } else {
            await logAction(`🤖 ${character.name}이(가) 제자리를 유지합니다.`, "system");
        }

        setTimeout(async () => {
            if (canAttackAfterMove) {
                await logAction(`🤖 ${character.name}이(가) ${closestTarget.name}을(를) ${attackSkill.name}(으)로 공격!`, "system");
                await executeSkill(character, closestTarget, attackSkillId);
            } else {
                await logAction(`🤖 공격할 수 없어 ${character.name}이(가) 턴을 종료합니다.`, "system");
                await nextTurn();
            }
        }, moved ? 1500 : 500);
    }
    async function updateTurnIndex(newIndex, reverse = false) {
    if (characters.length === 0 || !gameId) return;

    let newRound = round;
    if (!reverse && newIndex < currentTurnIndex) {
        newRound++;
        await logAction(`▶️ 라운드 ${newRound} 시작`, "system");
    } else if (reverse && newIndex > currentTurnIndex) {
        if (newRound > 1) {
            newRound--;
            await logAction(`◀️ 이전 라운드로 돌아갑니다. (라운드 ${newRound})`, "system");
        }
    }
    
    currentTurnIndex = newIndex % characters.length;
    const currentTurnChar = characters[currentTurnIndex];
    const currentTurnCharId = currentTurnChar?.id || null;

    if (maxRounds > 0 && newRound > maxRounds) {
        await logAction(`- 전투 종료: 최대 라운드 도달 -`, "system");
        await showGameSummaryModal("시간 종료", `최대 라운드(${maxRounds})에 도달하여 전투가 종료되었습니다.`);
        return;
    } 
    
    await setDoc(doc(db, 'games', gameId), { round: newRound, currentTurnIndex, currentTurnCharId }, { merge: true });
    
     if (gameState === 'STARTED' && currentTurnChar && !reverse) {

        const isGameOver = await checkGameEndCondition();
        if (isGameOver) return;

        const newMp = Math.min(currentTurnChar.maxMp, currentTurnChar.mp + MP_REGEN_PER_TURN);
        if (newMp > currentTurnChar.mp) {
            await updateDoc(doc(db, 'games', gameId, 'characters', currentTurnChar.id), { mp: newMp });
            await logAction(`💧 ${currentTurnChar.name}이(가) **${MP_REGEN_PER_TURN} MP**를 회복했습니다.`, "system");
        }
        
        await checkAndApplyTileDamage(currentTurnChar);
    }
}


    async function nextTurn() {
        if (characters.length === 0 || !gameId) return;
        turnPhase = 'MOVE';
        selectedSkill = 'move';
        let nextIndex = currentTurnIndex;
        do {
            nextIndex = (nextIndex + 1) % characters.length;
        } while (characters.length > 1 && characters[nextIndex] && (characters[nextIndex].hp <= 0 || characters[nextIndex].x === null));
        
        await updateTurnIndex(nextIndex);
        selectedCharacterId = null;
        // IMPORTANT: Clear UI highlights on turn change
        document.querySelectorAll('.combat-range').forEach(cell => cell.classList.remove('combat-range', 'attack-range-move', 'attack-range-skill', 'heal-range-skill'));
    }
    
    async function previousTurn() {
        if (characters.length === 0 || !gameId) return;
        turnPhase = 'MOVE';
        selectedSkill = 'move';
        let prevIndex = currentTurnIndex;
        do {
            prevIndex = (prevIndex - 1 + characters.length) % characters.length;
        } while (characters.length > 1 && characters[prevIndex] && (characters[prevIndex].hp <= 0 || characters[prevIndex].x === null));

        await updateTurnIndex(prevIndex, true);
        selectedCharacterId = null;
        // IMPORTANT: Clear UI highlights on turn change
        document.querySelectorAll('.combat-range').forEach(cell => cell.classList.remove('combat-range', 'attack-range-move', 'attack-range-skill', 'heal-range-skill'));
    }

    // Helper function to handle HP change
    async function updateHP(char, amount, logType) {
        const newHp = Math.min(char.maxHp, Math.max(0, char.hp + amount));
        await updateDoc(doc(db, 'games', gameId, 'characters', char.id), { hp: newHp });
        return newHp;
    }
    
    // Helper function to handle MP change
    async function updateMP(char, amount) {
         const newMp = Math.min(char.maxMp, Math.max(0, char.mp + amount));
         await updateDoc(doc(db, 'games', gameId, 'characters', char.id), { mp: newMp });
         return newMp;
    }


    function findTargetsInAoe(centerX, centerY, range, shape, skillType, attackerType) {
    const affectedCells = new Set();
    for (let dy = -range; dy <= range; dy++) {
        for (let dx = -range; dx <= range; dx++) {
            let inShape = (shape === 'diamond' && Math.abs(dx) + Math.abs(dy) <= range) || 
              (shape === 'square') || 
              (shape === 'cross' && (dx === 0 || dy === 0)); // 👈 십자 모양 로직 추가
            if (inShape) {
                const x = centerX + dx;
                const y = centerY + dy;
                if (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE) affectedCells.add(`${x},${y}`);
            }
        }
    }
    
    const targets = new Set();
    characters.forEach(char => {
        if (char.x !== null) {
            const isEnemy = char.type !== attackerType;
            const isAlly = char.type === attackerType;
            
            let isEligible = false;
            
            // Standard damage/heal targeting
            if ((skillType === 'Heal' || skillType === 'Support') && isAlly && char.hp > 0) isEligible = true;
            if (skillType !== 'Heal' && skillType !== 'Support' && isEnemy && char.hp > 0) isEligible = true;
            
            // Special case for Resurrect
            const skill = SKILLS[selectedSkill];
            if (skill && skill.targetType === 'ALLY_DEAD' && isAlly && char.hp <= 0) isEligible = true;

            if (isEligible) {
                const size = char.size || 1;
                // 캐릭터가 차지하는 모든 칸(size x size)을 순회합니다.
                for (let ex = 0; ex < size; ex++) {
                    for (let ey = 0; ey < size; ey++) {
                        if (affectedCells.has(`${char.x + ex},${char.y + ey}`)) {
                            targets.add(char);
                            return; // forEach 루프에서 현재 반복을 종료하고 다음 캐릭터로 넘어갑니다.
                        }
                    }
                }
            }
        }
    });
    return Array.from(targets);
}

    async function applyDamage(attacker, defender, skillId) {
    const skill = SKILLS[skillId];
    if (!skill) return;
    
    if (skill.mpCost > 0) await updateMP(attacker, -skill.mpCost);

    const defenderToken = document.querySelector(`.character-token[data-char-id="${defender.id}"]`);
    if (defenderToken) {
        defenderToken.classList.add('hit-animation', 'show-hit-overlay');
        setTimeout(() => {
            defenderToken.classList.remove('hit-animation', 'show-hit-overlay');
        }, 1000);
    }

    let baseAttack = Math.floor(Math.random() * (attacker.maxAttack - attacker.minAttack + 1)) + attacker.minAttack;
    let attackBonus = 0;

    if (attacker.statusEffects && attacker.statusEffects.length > 0) {
        const strengthUpEffect = attacker.statusEffects.find(e => e.id === 'strengthUp');
        if (strengthUpEffect) {
            let bonus = baseAttack * (strengthUpEffect.value - 1);
            attackBonus += bonus;
            logAction(`⚔️ ${attacker.name}의 [${strengthUpEffect.name}] 효과! 공격력이 ${bonus.toFixed(0)} 증가합니다.`, "system");
        }
        const strengthDownEffect = attacker.statusEffects.find(e => e.id === 'strengthDown');
        if (strengthDownEffect) {
            let penalty = baseAttack * (1 - strengthDownEffect.value);
            attackBonus -= penalty;
            logAction(`⚔️ ${attacker.name}의 [${strengthDownEffect.name}] 효과! 공격력이 ${penalty.toFixed(0)} 감소합니다.`, "system");
        }
    }
    let finalAttack = baseAttack + attackBonus;

    let baseDefense = Math.floor(Math.random() * (defender.maxDefense - defender.minDefense + 1)) + defender.minDefense;
    let defenseBonus = 0;

    if (defender.statusEffects && defender.statusEffects.length > 0) {
        const defenseUpEffect = defender.statusEffects.find(e => e.id === 'defenseUp');
        if (defenseUpEffect) {
            let bonus = baseDefense * (defenseUpEffect.value - 1);
            defenseBonus += bonus;
            logAction(`🛡️ ${defender.name}의 [${defenseUpEffect.name}] 효과! 방어력이 ${bonus.toFixed(0)} 증가합니다.`, "system");
        }
        const defenseDownEffect = defender.statusEffects.find(e => e.id === 'defenseDown');
        if (defenseDownEffect) {
            let penalty = baseDefense * (1 - defenseDownEffect.value);
            defenseBonus -= penalty;
            logAction(`🛡️ ${defender.name}의 [${defenseDownEffect.name}] 효과! 방어력이 ${penalty.toFixed(0)} 감소합니다.`, "system");
        }
    }
    let finalDefense = baseDefense + defenseBonus;

    const finalDamage = Math.max(1, Math.round((finalAttack * skill.multiplier) - finalDefense));
    const newHp = await updateHP(defender, -finalDamage, "damage");
        await triggerCombatText(defender, `-${finalDamage.toFixed(0)}`, 'damage');

    let bonusText = "";
    if (attackBonus > 0) bonusText += `+공격 ${attackBonus.toFixed(0)}`;
    if (defenseBonus > 0) bonusText += (bonusText ? ", " : "") + `-방어 ${defenseBonus.toFixed(0)}`;
    
    let message = `💥 ${attacker.name}의 ${skill.name}! ${defender.name}에게 **${finalDamage.toFixed(0)} 피해!** ${bonusText ? `(${bonusText})` : ''}`;
    if (newHp === 0) message += `<br>💀 ${defender.name}이(가) 쓰러졌습니다!`;
    await logAction(message, "damage");
    
    return true;
}
    
    async function applyHealOrSupport(caster, target, skillId) {
    const skill = SKILLS[skillId];
    if (!skill) return false;
    
    const isResurrect = skill.targetType === 'ALLY_DEAD';
    const isHpTransfer = skillId === 'hp_transfer';
    const isMpTransfer = skillId === 'mp_transfer';
    
    if (caster.mp < skill.mpCost || (isHpTransfer && caster.hp <= skill.hpCost)) {
         const resource = isHpTransfer ? 'HP' : 'MP';
         const cost = isHpTransfer ? skill.hpCost : skill.mpCost;
         const current = isHpTransfer ? caster.hp : caster.mp;
         await logAction(`⚠️ ${caster.name}이(가) ${resource}가 부족하여 ${skill.name}을(를) 시전하지 못했습니다. (필요: ${cost} ${resource}, 현재: ${current} ${resource})`, "system");
         return false;
    }
    
    if (!isResurrect && target.hp <= 0) {
        await logAction(`⚠️ ${caster.name}은(는) 사망한 ${target.name}에게 ${skill.name}을(를) 사용할 수 없습니다.`, "system");
        return false;
    }

    if (isResurrect && target.hp > 0) {
        await logAction(`⚠️ ${target.name}은(는) 이미 살아있습니다. 부활 주문을 사용할 수 없습니다.`, "system");
        return false;
    }

    if (skill.mpCost > 0) await updateMP(caster, -skill.mpCost);
    if (skill.hpCost > 0) await updateHP(caster, -skill.hpCost, "damage");

    const targetToken = document.querySelector(`.character-token[data-char-id="${target.id}"]`);
    if (targetToken) {
        const animationClass = isMpTransfer ? 'heal-animation' : 'heal-animation'; 
        const overlayClass = 'show-heal-overlay';
        targetToken.classList.add(animationClass, overlayClass);
        setTimeout(() => {
            targetToken.classList.remove(animationClass, overlayClass);
        }, 1000);
    }

    let message;
    
    if (isResurrect) {
        const reviveHp = Math.round(target.maxHp * skill.multiplier);
        await updateDoc(doc(db, 'games', gameId, 'characters', target.id), { hp: reviveHp, mp: 0 });
        message = `👼 ${caster.name}의 ${skill.name}! **${target.name}**을(를) **${reviveHp} HP, 0 MP**로 부활시켰습니다.`;
        
        await triggerCombatText(target, `+${reviveHp}`, 'heal');
        
        await logAction(message, "heal");
    } else if (isHpTransfer) {
        const healAmount = Math.max(1, Math.round(caster.minAttack * skill.multiplier));
        const newHp = await updateHP(target, healAmount, "heal");
        message = `💖 ${caster.name}이(가) **${skill.hpCost} HP**를 소모하여 ${target.name}에게 **${healAmount} HP**를 전달했습니다. (${target.hp} → ${newHp})`;
        
        await triggerCombatText(target, `+${healAmount}`, 'heal');
        await triggerCombatText(caster, `-${skill.hpCost}`, 'damage');

        await logAction(message, "heal");
    } else if (isMpTransfer) {
        const mpAmount = skill.multiplier;
        const newMp = await updateMP(target, mpAmount);
        message = `💧 ${caster.name}이(가) **${skill.mpCost} MP**를 소모하여 ${target.name}에게 **${mpAmount} MP**를 전달했습니다. (${target.mp} → ${newMp})`;
        await logAction(message, "system");
    } else if (skill.type === 'Heal') {
        const baseHeal = Math.floor(Math.random() * (caster.maxAttack - caster.minAttack + 1)) + caster.minAttack;
        const finalHeal = Math.max(1, Math.round(baseHeal * skill.multiplier));
        const newHp = await updateHP(target, finalHeal, "heal");
        message = `✨ ${caster.name}의 ${skill.name}! ${target.name}의 **HP를 ${finalHeal.toFixed(0)} 회복!** (${target.hp} → ${newHp})`;

        await triggerCombatText(target, `+${finalHeal.toFixed(0)}`, 'heal');

        await logAction(message, "heal");
    }
    
    return true;
}

async function applyStatusEffect(target, effectInfo) {
    if (!target || !effectInfo || !effectInfo.id || !PREDEFINED_EFFECTS[effectInfo.id]) return;

    const baseEffect = PREDEFINED_EFFECTS[effectInfo.id];

    const newEffect = {
        ...baseEffect, // baseEffect의 모든 속성(id, name, effectType 등)을 여기에 복사합니다.
        turnsRemaining: effectInfo.turns,
        isNew: true
    };

    if (effectInfo.value !== undefined) {
        newEffect.value = effectInfo.value;
    }

    const targetRef = doc(db, 'games', gameId, 'characters', target.id);
    
    const targetDoc = await getDoc(targetRef);
    if (!targetDoc.exists()) return;

    const currentEffects = targetDoc.data().statusEffects || [];

    if (currentEffects.some(e => e.id === newEffect.id)) {
        console.log(`${target.name}은(는) 이미 ${newEffect.name} 효과를 받고 있습니다.`);
        return;
    }

    const updatedEffects = [...currentEffects, newEffect];
    await updateDoc(targetRef, { statusEffects: updatedEffects });
    const icon = STATUS_EFFECT_ICONS[newEffect.id] || '🔗';
    
    await logAction(`${icon} ${target.name}이(가) [${newEffect.name}] 효과를 받았습니다! (${newEffect.turnsRemaining}턴 지속)`, "system");
}
    async function showGameSummaryModal(title, message) {
    const remainingPCs = characters.filter(c => c.type === 'PC' && c.hp > 0 && c.x !== null).length;
    const totalPCs = characters.filter(c => c.type === 'PC').length;
    const remainingEnemies = characters.filter(c => c.type === 'ENEMY' && c.hp > 0 && c.x !== null).length;
    const totalEnemies = characters.filter(c => c.type === 'ENEMY').length;

    const resultMessage = `
        ${message}
        <hr class="my-4 border-gray-600">
        <h4 class="font-bold text-lg mb-2">최종 결과</h4>
        <p>남은 아군: ${remainingPCs} / ${totalPCs}</p>
        <p>남은 적군: ${remainingEnemies} / ${totalEnemies}</p>
    `;

    let buttons;
    if (isAdmin) {
        buttons = [{
            text: "확인 (게임 재시작)",
            class: "bg-indigo-600",
            onClick: async () => {
                await resetAllGameData();
            }
        }];
    } else {
        buttons = [{
            text: "확인",
            class: "bg-indigo-600"
        }];
    }

    showCustomModal(title, resultMessage, buttons);
}
        async function checkGameEndCondition() {
    if (!isAdmin) return false;

    const remainingPCs = characters.filter(c => c.type === 'PC' && c.hp > 0 && c.x !== null).length;
    const remainingEnemies = characters.filter(c => c.type === 'ENEMY' && c.hp > 0 && c.x !== null).length;

    let gameResult = null;

    if (remainingPCs === 0) {
        gameResult = { title: "패배...", message: "모든 아군이 쓰러졌습니다." };
    } else if (remainingEnemies === 0) {
        gameResult = { title: "승리!", message: "모든 적을 물리쳤습니다." };
    }

    if (gameResult) {
        await setDoc(doc(db, 'games', gameId), { 
            gameState: 'ENDED',
            gameResult: gameResult // 모든 유저가 이 정보를 보고 팝업을 띄우게 됩니다.
        }, { merge: true });
        return true; // 게임 종료됨
    }

    return false; // 게임 계속됨
}
    async function executeSkill(attacker, target, skillId) {
    const skill = SKILLS[skillId];
    if (!skill || !target) return;

    let actionSucceeded = false;
    let affectedTargets = [];

    if (skill.category === 'Attack') {
        if (target.type === attacker.type) {
            await logAction(`⚠️ ${attacker.name}은(는) 아군에게 공격할 수 없습니다.`, "system");
            return;
        }

        if (skill.isAoe) {
            const targetsInAoe = findTargetsInAoe(target.x, target.y, skill.aoeRange, skill.aoeShape, skill.type, attacker.type);
            for (const aoeTarget of targetsInAoe) {
                const success = await applyDamage(attacker, aoeTarget, skillId);
                if (success) {
                    actionSucceeded = true;
                    affectedTargets.push(aoeTarget);
                }
            }
        } else {
            // 단일 공격 로직
            const success = await applyDamage(attacker, target, skillId);
            if (success) {
                actionSucceeded = true;
                affectedTargets.push(target);
            }
        }
    } else if (skill.category === 'Heal' || skill.category === 'Support') {
        if (target.type !== attacker.type) {
            await logAction(`⚠️ ${attacker.name}은(는) 적군에게 ${skill.name}을(를) 사용할 수 없습니다.`, "system");
            return;
        }
        const success = await applyHealOrSupport(attacker, target, skillId);
        if (success) {
            actionSucceeded = true;
            affectedTargets.push(target);
        }
    } else {
        actionSucceeded = true; 
    }
    
    if (skill.appliesEffect && affectedTargets.length > 0) {
        for (const finalTarget of affectedTargets) {
            // 💥 여기가 핵심: attacker가 아닌 finalTarget에게 효과를 적용합니다.
            await applyStatusEffect(finalTarget, skill.appliesEffect);
        }
    }
    
    if (actionSucceeded) {
        const isGameOver = await checkGameEndCondition();
        if (isGameOver) return;

        if (attacker.type === 'PC' && roundPhase === 'PLAYER_PHASE') {
            await updateDoc(doc(db, 'games', gameId, 'characters', attacker.id), { hasActedThisRound: true });
            selectedCharacterId = null;
            selectedSkill = null;
            render();
        }

        if (attacker.type === 'ENEMY' && roundPhase === 'ENEMY_EXECUTION') {
            await updateDoc(doc(db, 'games', gameId, 'characters', attacker.id), { nextAction: null });
            selectedCharacterId = null;
            selectedSkill = null;
            render();
        }
    } else {
        render(); 
    }
}

    async function undoMove() {
    const selectedCharacter = characters.find(c => c.id === selectedCharacterId);
    
    if (!selectedCharacter || !preMovePosition) return;
    await updateDoc(doc(db, 'games', gameId, 'characters', selectedCharacter.id), { x: preMovePosition.x, y: preMovePosition.y });
    //await logAction(`↩️ ${selectedCharacter.name}이(가) 이동을 취소했습니다.`, "system");
    selectedCharActionPhase = 'MOVE'; // <-- [수정] 이동 단계로 되돌림
    selectedSkill = 'move';
    render();
}
    
    // --- Rendering & UI ---
    function showCustomModal(title, message, buttons) {
        document.getElementById('custom-modal-title').textContent = title;
        document.getElementById('custom-modal-message').innerHTML = message;
        const buttonsContainer = document.getElementById('custom-modal-buttons');
        buttonsContainer.innerHTML = '';
        buttons.forEach(btn => {
            const buttonEl = document.createElement('button');
            buttonEl.textContent = btn.text;
            buttonEl.className = `${btn.class} text-white font-bold py-2 px-4 transition`;
            buttonEl.onclick = () => { closeModal('custom-modal'); if (btn.onClick) btn.onClick(); };
            buttonsContainer.appendChild(buttonEl);
        });
        document.getElementById('custom-modal').classList.remove('hidden');
    }

    // --- PC Login Handlers ---
    function openPCLoginModal() {
         const pcChars = characters.filter(c => c.type === 'PC');
         if (pcChars.length === 0) {
             return;
         }

         populatePCLoginSelect(pcChars);
         pcLoginModal.classList.remove('hidden');
         document.getElementById('char-login-password-input').focus();
    }

    function populatePCLoginSelect(pcChars = characters.filter(c => c.type === 'PC')) {
        const selectEl = document.getElementById('char-login-name-select');
        selectEl.innerHTML = pcChars.map(char => `<option value="${char.id}">${char.name} (${char.type})</option>`).join('');
    }

    async function handlePCLogin() {
    const charId = document.getElementById('char-login-name-select').value;
    const password = document.getElementById('char-login-password-input').value;
    const errorP = document.getElementById('char-login-error');
    const targetChar = characters.find(c => c.id === charId);

    errorP.textContent = '';

    if (targetChar && targetChar.password === password) {
        loggedInCharId = charId;
        isAdmin = false;

        await updateDoc(doc(db, 'games', gameId, 'characters', charId), { isLoggedIn: true });
        
        closeModal('pc-login-modal');
        updateAuthStatus();
        showCustomModal("로그인 성공", `${targetChar.name}로 로그인했습니다.`, [{text:"확인", class:"bg-green-600"}]);
    } else {
        errorP.textContent = '비밀번호가 올바르지 않습니다.';
    }
}

async function handleLogout() {
    if (loggedInCharId) {
        await updateDoc(doc(db, 'games', gameId, 'characters', loggedInCharId), { isLoggedIn: false });
    }

    loggedInCharId = null;
    isAdmin = false;
    isMapEditMode = false;
    updateAuthStatus();
    closeModal('user-info-modal');
    render();
    closeModal('map-edit-modal');
}
    
    // Function to update all status indicators
    function updateAuthStatus() {
        const char = characters.find(c => c.id === loggedInCharId);
        let authText = '비로그인';
        let authColor = 'var(--text-secondary)';
        let isUserLoggedIn = false;
        
        if (isAdmin) {
            authText = `관리자 (토큰 이동: ${isAdminMoveAllowed ? '허용' : '제한'}, 맵 편집: ${isMapEditMode ? 'ON' : 'OFF'})`;
            authColor = 'var(--log-admin)';
        } else if (loggedInCharId) {
            authText = `${char ? char.name : 'Unknown PC'} (${char ? char.type : 'PC'})`;
            authColor = 'var(--accent-primary)';
            isUserLoggedIn = true;
        }

        // Update User Info Modal fields
        document.getElementById('user-info-game-id-display').value = gameId || "N/A";
        const authCharSpan = document.getElementById('user-info-auth-char');
        authCharSpan.textContent = authText;
        authCharSpan.style.color = authColor;

        const userInfoLoginBtn = document.getElementById('user-info-login-btn');
        const userInfoLogoutBtn = document.getElementById('user-info-logout-btn');

        if (gameId && characters.some(c => c.type === 'PC') && !isAdmin && !loggedInCharId) {
            userInfoLoginBtn.classList.remove('hidden');
            userInfoLogoutBtn.classList.add('hidden');
        } else if (isAdmin || isUserLoggedIn) {
            userInfoLoginBtn.classList.add('hidden');
            userInfoLogoutBtn.classList.remove('hidden');
        } else {
            userInfoLoginBtn.classList.add('hidden');
            userInfoLogoutBtn.classList.add('hidden');
        }

        // Bind listeners for User Info Modal buttons
        userInfoLoginBtn.onclick = openPCLoginModal;
        userInfoLogoutBtn.onclick = handleLogout;
    }
    
    // --- End PC Login Handlers ---

    function initializeBoard() {
        if (isBoardInitialized) return;
        gameBoard.innerHTML = '';
        for (let y = 0; y < BOARD_SIZE; y++) {
            for (let x = 0; x < BOARD_SIZE; x++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.x = x;
                cell.dataset.y = y;
                gameBoard.appendChild(cell);
            }
        }
        isBoardInitialized = true;
    }

     function highlightRange(char, skillId) {
        document.querySelectorAll('.combat-range').forEach(cell => cell.classList.remove('combat-range', 'attack-range-move', 'attack-range-skill', 'heal-range-skill'));
        
        if (!char || char.x === null || !SKILLS[skillId]) return;

    // skill과 isMove를 여기서 한 번만 선언합니다.
    const skill = SKILLS[skillId];
    const isMove = skill.id === 'move';

    // 속박 상태를 체크합니다.
    if (isMove && char.statusEffects?.some(e => e.id === 'rooted')) {
        return; 
    }

    const range = (skill.id === 'move' && char.moveRange !== undefined) ? char.moveRange : skill.range;
    const size = char.size || 1;
    
    const isAttack = skill.category === 'Attack';
    const isHealOrSupport = skill.category === 'Heal' || skill.category === 'Support';
    
    const shape = skill.rangeShape || 'diamond';
        const validCells = new Set();

        if (isMove) {
            const originX = char.x;
            const originY = char.y;
            for (let dy = -range; dy <= range; dy++) {
                for (let dx = -range; dx <= range; dx++) {
                    if (Math.abs(dx) + Math.abs(dy) <= range) {
                        const targetX = originX + dx;
                        const targetY = originY + dy;

                        if (canPlaceCharacter(char, targetX, targetY)) {
                            validCells.add(`${targetX},${targetY}`);
                        }
                    }
                }
            }
            

        } else if (isAttack || isHealOrSupport) {
             // Action range (기존 로직과 동일)
            for (let ex = 0; ex < size; ex++) {
                for (let ey = 0; ey < size; ey++) {
                    const originX = char.x + ex, originY = char.y + ey;
                    for (let dy = -range; dy <= range; dy++) {
                        for (let dx = -range; dx <= range; dx++) {
                            let inShape = (shape === 'diamond' && Math.abs(dx) + Math.abs(dy) <= range) ||
                                          (shape === 'square' && Math.abs(dx) <= range && Math.abs(dy) <= range) ||
                                          (shape === 'cross' && ((dx === 0 && Math.abs(dy) <= range) || (dy === 0 && Math.abs(dx) <= range)));
                            if (inShape) {
                                const targetX = originX + dx, targetY = originY + dy;
                                if (targetX >= 0 && targetX < BOARD_SIZE && targetY >= 0 && targetY < BOARD_SIZE) {
                                    validCells.add(`${targetX},${targetY}`);
                                }
                            }
                        }
                    }
                }
            }
            if (!skill.isAoe) {
                for (let ex = 0; ex < size; ex++) {
                    for (let ey = 0; ey < size; ey++) {
                        validCells.delete(`${char.x + ex},${char.y + ey}`);
                    }
                }
            }
        }

        const className = isMove ? 'attack-range-move' : (isHealOrSupport ? 'heal-range-skill' : 'attack-range-skill');
        validCells.forEach(coord => {
            const [x, y] = coord.split(',');
            const cell = document.querySelector(`.cell[data-x='${x}'][data-y='${y}']`);
            if (cell) cell.classList.add('combat-range', className);
        });
    }
    
    function renderCharacterSelectionOverlay() {
        const selectionList = document.getElementById('selection-list');
        selectionList.innerHTML = characters.length === 0 ? `<div class="text-white/70 text-lg w-full text-center p-4">인증 중...</div>` : '';
        if (characters.length === 0) return;
        
        const renderCard = (char) => {
            const isSelected = char.id === selectedCharacterId, isPlaced = char.x !== null, isDead = char.hp <= 0, isEnemy = char.type === 'ENEMY';
            const canBeDragged = (!isEnemy && (gameState === 'PREPARATION' && !isDead)) || (!isPlaced && !isDead) || (isAdmin && isAdminMoveAllowed);
            
            const charCard = document.createElement('div');
            charCard.className = `char-card-item ${isSelected ? 'selected' : ''} ${isEnemy ? 'enemy-card' : ''}`;
            charCard.dataset.charId = char.id;
            charCard.draggable = canBeDragged;
            
            if (char.imageUrl) charCard.style.backgroundImage = `url(${char.imageUrl})`;
            else charCard.innerHTML = `<span class="card-placeholder font-title">${char.name.charAt(0)}</span>`;
            if (isDead) { charCard.style.filter = 'grayscale(100%) opacity(0.7)'; charCard.draggable = false; }
            
            const infoContainer = document.createElement('div');
            infoContainer.className = 'char-card-info';
            infoContainer.innerHTML = `
                <div class="font-bold">${char.name} <span class="text-red-400 text-sm">${isDead ? '(사망)' : ''}</span></div>
                <div class="flex justify-between items-center text-sm">
                    <span class="text-white/80">${isPlaced ? `(${char.x}, ${char.y})` : '미배치 (드래그)'}</span>
                    <button class="details-btn">상세</button>
                </div>`;
            
            infoContainer.querySelector('button').onclick = (e) => { e.stopPropagation(); openProfileModal(char); };
            charCard.appendChild(infoContainer);
            charCard.onclick = () => {
    const isMyTurn = (loggedInCharId === char.id && characters[currentTurnIndex]?.id === char.id);
    const canSelect = (isMyTurn && gameState === 'STARTED');

    if (isPlaced && !isDead) {
                    if (isAdmin) {
                        // previewCharacterId = char.id;      
                        // selectedCharacterId = null;          
                    } else if (canSelect) {
            selectedCharacterId = char.id;
            turnPhase = 'MOVE';
            selectedSkill = 'move';
            preMovePosition = { x: char.x, y: char.y };
        }
        render();
    }
};
            if (canBeDragged) charCard.ondragstart = (e) => e.dataTransfer.setData('text/plain', char.id);
            return charCard;
        };

        const pcContainer = document.createElement('div');
        pcContainer.className = 'flex gap-4';
        characters.filter(c => c.type === 'PC').forEach(char => pcContainer.appendChild(renderCard(char)));
        selectionList.appendChild(pcContainer);

        const enemyContainer = document.createElement('div');
        enemyContainer.className = 'flex gap-4 pl-4 border-l-2 border-red-800/50';
        characters.filter(c => c.type === 'ENEMY').forEach(char => enemyContainer.appendChild(renderCard(char)));
        selectionList.appendChild(enemyContainer);
    }

function renderSkillButtons(selectedChar) {
    skillControls.innerHTML = ''; 

    if (gameState === 'PREPARATION') {
        skillControls.innerHTML = `<p class="text-sm text-gray-400 mt-4">준비 단계입니다. 캐릭터를 보드에 배치하세요.</p>`;
        
        if (isAdmin) {
            skillControls.innerHTML += `
            <div class="mt-4 space-y-2">
                <button id="admin-start-game-btn" class="w-full bg-green-600 p-2 font-bold">⚔️ 게임 시작</button>
            </div>`;
        }
        
        const startGameBtn = document.getElementById('admin-start-game-btn');
        if(startGameBtn) {
            startGameBtn.onclick = async () => {
                if (gameId) {
                    await setDoc(doc(db, 'games', gameId), { 
                        gameState: 'STARTED',
                        roundPhase: 'ENEMY_FORESHADOW' 
                    }, { merge: true });

                    const batch = writeBatch(db);
                    characters.forEach(char => {
                        const charRef = doc(db, 'games', gameId, 'characters', char.id);
                        batch.update(charRef, { hasActedThisRound: false, nextAction: null });
                    });
                    await batch.commit();
                    
                    await logAction(`⚔️ 게임이 시작되었습니다! 라운드 1의 적 행동 예고를 시작합니다.`, "system");
                }
            };
        }

        return; 
    }

    if (roundPhase === 'ENEMY_FORESHADOW') {
        if (isAdmin) {
            const selectedEnemy = characters.find(c => c.id === adminSelectedEnemyId);
            let skillButtonsHtml = '';

            if (selectedEnemy) {
                skillButtonsHtml += `<h4 class="text-md font-bold text-yellow-300 mt-3 mb-2">사용할 스킬 선택:</h4><div class="flex flex-wrap gap-2">`;
                selectedEnemy.skills.forEach(id => {
                    const skill = SKILLS[id];
                    if (skill) {
                        const isSelected = adminForeshadowSkillId === id;
                        skillButtonsHtml += `<button data-skill-id="${id}" class="skill-btn foreshadow-skill-btn ${isSelected ? 'ring-2 ring-red-400' : ''} p-2 flex items-center flex-col text-xs font-semibold">
                                        ${skill.icon} ${skill.name}
                                      </button>`;
                    }
                });
                skillButtonsHtml += `</div>`;
            }

            skillControls.innerHTML = `
                <h3 class="text-lg font-bold mb-2 text-red-400">적 행동 예고</h3>
                <p class="text-sm text-gray-400 mb-4">① 적 선택 → ② 스킬 선택 → ③ 대상 아군 클릭</p>
                <p class="text-sm font-semibold mb-2">선택된 적: <span class="text-yellow-400">${selectedEnemy?.name || '없음'}</span></p>
                <div id="foreshadow-skill-container" class="mb-4">${skillButtonsHtml}</div>
                <button id="end-foreshadow-btn" class="w-full bg-green-600 p-2 font-bold">✔️ 예고 완료</button>
            `;
            document.getElementById('end-foreshadow-btn').onclick = () => setDoc(doc(db, 'games', gameId), { roundPhase: 'PLAYER_PHASE' }, { merge: true });

            document.querySelectorAll('.foreshadow-skill-btn').forEach(btn => {
                btn.onclick = (e) => {
                    adminForeshadowSkillId = e.currentTarget.dataset.skillId;
                    render(); 
                };
            });
        } else {
            skillControls.innerHTML = `<p class="text-sm text-gray-400 mt-4">관리자가 적의 행동을 설정하고 있습니다...</p>`;
        }
        return;
    }

    if (roundPhase === 'ENEMY_EXECUTION') {
        if (isAdmin) {
            const isManuallyControllingEnemy = selectedChar && selectedChar.type === 'ENEMY';
            if (isManuallyControllingEnemy) {
                let html = `<h3 class="text-lg font-bold mb-2 text-red-500">[수동 조작] ${selectedChar.name} 행동</h3>`;
                html += `<p class="text-sm font-semibold text-blue-400 mb-3">MP: ${selectedChar.mp}/${selectedChar.maxMp}</p>`;
                
                if (selectedCharActionPhase === 'MOVE') {
                    html += `<p class="text-sm text-gray-400">이동할 위치를 선택하세요.</p>`;
                } else { 
                    html += `<div class="flex flex-wrap gap-2">`;
                    selectedChar.skills.forEach(id => {
                        const skill = SKILLS[id];
                        if (skill && skill.id !== 'move') {
                            const canUse = selectedChar.mp >= skill.mpCost;
                            const disabledClass = canUse ? '' : 'opacity-50 cursor-not-allowed';
                            html += `<button data-skill-id="${id}" class="skill-btn ${selectedSkill === id ? 'ring-2 ring-red-400' : ''} text-white p-2 flex items-center flex-col text-xs font-semibold ${disabledClass}" ${canUse ? '' : 'disabled'}>
                                ${skill.icon} ${skill.name}
                                <span class="text-gray-400 text-xs">${skill.mpCost > 0 ? `[MP ${skill.mpCost}]` : ''}</span>
                                </button>`;
                        }
                    });
                    html += `</div>`;
                    html += `<button id="undo-move-btn" class="w-full mt-4 bg-gray-500 hover:bg-gray-600 text-white p-2">↩ 이동 취소</button>`;
                }
                
                html += `<button id="enemy-action-complete-btn" class="w-full mt-4 bg-purple-600 p-2 font-bold">✔️ 행동 완료 (턴 넘김)</button>`;
                skillControls.innerHTML = html;

                document.getElementById('enemy-action-complete-btn').onclick = async () => {
                    await updateDoc(doc(db, 'games', gameId, 'characters', selectedChar.id), { nextAction: null });
                    selectedCharacterId = null;
                    render();
                };
                document.getElementById('undo-move-btn')?.addEventListener('click', undoMove);
                document.querySelectorAll('.skill-btn').forEach(btn => {
                    btn.onclick = (e) => {
                         selectedSkill = e.currentTarget.dataset.skillId;
                         render();
                    }
                });

            } else {
                // 아직 행동하지 않은 적이 있는지 확인
                const enemiesToAct = characters.filter(c => c.type === 'ENEMY' && c.hp > 0 && c.nextAction);
                if (enemiesToAct.length > 0) {
                     skillControls.innerHTML = `
                        <h3 class="text-lg font-bold mb-2 text-red-400">적 행동 실행</h3>
                        <p class="text-sm text-gray-400 mb-4">자동으로 실행하거나, 수동으로 적을 선택하여 조작하세요.</p>
                        <button id="execute-enemies-btn" class="w-full bg-red-800 p-2 font-bold">🤖 자동 행동 개시</button>
                    `;
                    document.getElementById('execute-enemies-btn').onclick = executeEnemyActions;
                } else {
                    // 모든 적이 행동을 마쳤을 때
                    skillControls.innerHTML = `
                        <h3 class="text-lg font-bold mb-2 text-green-400">모든 적 행동 완료</h3>
                        <p class="text-sm text-gray-400 mb-4">다음 라운드로 진행합니다.</p>
                        <button id="go-to-next-round-btn" class="w-full bg-blue-600 p-2 font-bold">다음 라운드로</button>
                    `;
                    document.getElementById('go-to-next-round-btn').onclick = advanceRoundPhase;
                }
            }
        } else {
            skillControls.innerHTML = `<p class="text-sm text-gray-400 mt-4">적들이 행동하고 있습니다...</p>`;
        }
        return;
    }
    
    // 3. 미리보기 UI
    const isPreviewing = selectedChar && selectedChar.id === previewCharacterId;
    if (isPreviewing) {
        let html = `<h3 class="text-lg font-bold mb-2 text-cyan-400">👀 ${selectedChar.name} 미리보기</h3>`;
        html += `<p class="text-sm text-gray-400 mb-3">이동 및 스킬 범위를 확인하고 있습니다.</p>`;
        html += `<p class="text-sm font-semibold text-blue-400 mb-3">MP: ${selectedChar.mp}/${selectedChar.maxMp}</p>`;
        html += `<div class="flex flex-wrap gap-2">`;
        const moveSkill = SKILLS['move'];
        if(moveSkill) {
             html += `<button data-skill-id="move" class="skill-btn ${(!selectedSkill || selectedSkill === 'move') ? `ring-2 ring-yellow-400` : ''} text-white p-2 flex items-center flex-col text-xs font-semibold">${moveSkill.icon} ${moveSkill.name}</button>`;
        }
        selectedChar.skills.forEach(id => {
            const skill = SKILLS[id];
            if (!skill || skill.id === 'move') return;
            const isHealSupport = skill.category === 'Heal' || skill.category === 'Support';
            const ringColor = isHealSupport ? 'ring-green-400' : 'ring-red-400';
            html += `<button data-skill-id="${skill.id}" class="skill-btn ${selectedSkill === skill.id ? `ring-2 ${ringColor}` : ''} text-white p-2 flex items-center flex-col text-xs font-semibold">${skill.icon} ${skill.name}</button>`;
        });
        html += `</div>`;
        skillControls.innerHTML = html;
        document.querySelectorAll('.skill-btn').forEach(btn => btn.onclick = (e) => { 
            selectedSkill = e.currentTarget.dataset.skillId;
            render(); 
        });
        return;
    }

    // 4. 플레이어 행동 단계 UI
    if (roundPhase === 'PLAYER_PHASE') {
    const pcs = characters.filter(c => c.type === 'PC' && c.hp > 0 && c.x !== null);
    const allPlayersActed = pcs.length > 0 && pcs.every(c => c.hasActedThisRound);

    if (allPlayersActed) {
        if (isAdmin) {
            skillControls.innerHTML = `<h3 class="text-lg font-bold mb-2 text-green-400">모든 아군 행동 완료</h3><p class="text-sm text-gray-400 mb-4">적들이 행동을 시작합니다.</p><button id="end-player-phase-btn" class="w-full bg-red-600 p-2 font-bold">적 행동 시작</button>`;
            document.getElementById('end-player-phase-btn').onclick = advanceRoundPhase;
        } else {
            skillControls.innerHTML = `<p class="text-sm text-gray-400 mt-4">관리자가 턴을 넘기기를 기다리고 있습니다...</p>`;
        }
        return;
    }
    
    const isActionablePC = selectedChar && selectedChar.type === 'PC' && !selectedChar.hasActedThisRound;
    
    if (isActionablePC && (canControlCharacter(selectedChar.id) || (isAdmin && selectedChar.type === 'PC'))) {
        let html;
        if (isAdmin) {
             html = `<h3 class="text-lg font-bold mb-2 text-purple-400">👮 ${selectedChar.name} 행동 대리</h3>`;
        } else {
             html = `<h3 class="text-lg font-bold mb-2 text-green-400">${selectedChar.name} 행동</h3>`;
        }
        
        html += `<p class="text-sm font-semibold text-blue-400 mb-3">MP: ${selectedChar.mp}/${selectedChar.maxMp}</p>`;
        
        if (selectedCharActionPhase === 'MOVE') {
            html += `<p class="text-sm text-gray-400">이동할 위치를 선택하세요.</p>`;
        } else { 
            html += `<div class="flex flex-wrap gap-2">`;
            selectedChar.skills.forEach(id => {
                const skill = SKILLS[id];
                if (skill && skill.id !== 'move') {
                    const isHealSupport = skill.category === 'Heal' || skill.category === 'Support';
                    const ringColor = isHealSupport ? 'ring-green-400' : 'ring-red-400';
                    const canUse = selectedChar.mp >= skill.mpCost && (skill.hpCost === undefined || selectedChar.hp > skill.hpCost);
                    const disabledClass = canUse ? '' : 'opacity-50 cursor-not-allowed';
                    let costText = [skill.mpCost > 0 ? `MP ${skill.mpCost}` : '', skill.hpCost > 0 ? `HP ${skill.hpCost}` : ''].filter(Boolean).join(' ');
                    html += `<button data-skill-id="${id}" data-category="${skill.category}" class="skill-btn ${selectedSkill === id ? `ring-2 ${ringColor}` : ''} text-white p-2 flex items-center flex-col text-xs font-semibold ${disabledClass}" ${canUse ? '' : 'disabled'}>
                        ${skill.icon} ${skill.name}
                        <span class="text-gray-400 text-xs">${costText ? `[${costText}]` : ''}</span>
                        </button>`;
                }
            });
            html += `</div>`;
            if (!selectedChar.statusEffects?.some(e => e.id === 'rooted')) {
                html += `<button id="undo-move-btn" class="w-full mt-4 bg-gray-500 hover:bg-gray-600 text-white p-2">↩ 이동 취소</button>`;
            }
        }
        html += `<button id="action-complete-btn" class="w-full mt-4 p-2 font-bold">✔️ 행동 완료</button>`;
        skillControls.innerHTML = html;
        document.getElementById('action-complete-btn').onclick = async () => {
            await updateDoc(doc(db, 'games', gameId, 'characters', selectedChar.id), { hasActedThisRound: true });
            selectedCharacterId = null;
            selectedSkill = null; 
            render();
        };
        document.getElementById('undo-move-btn')?.addEventListener('click', undoMove);
        document.querySelectorAll('.skill-btn').forEach(btn => {
            btn.onclick = (e) => {
                 selectedSkill = e.currentTarget.dataset.skillId;
                 render();
            }
        });
        return;
    } else {
        const isPreviewingOtherChar = isAdmin && selectedChar && selectedChar.type === 'PC';
        if (isPreviewingOtherChar) {
            let html = `<h3 class="text-lg font-bold mb-2 text-cyan-400">👀 ${selectedChar.name} 미리보기</h3>`;
            html += `<p class="text-sm text-gray-400 mb-3">드래그앤드롭으로 이동하거나, 스킬 범위를 확인하세요.</p>`;
            html += `<p class="text-sm font-semibold text-blue-400 mb-3">MP: ${selectedChar.mp}/${selectedChar.maxMp}</p>`;
            html += `<div class="flex flex-wrap gap-2">`;
            const moveSkill = SKILLS['move'];
            if(moveSkill) {
                 html += `<button data-skill-id="move" class="skill-btn ${(!selectedSkill || selectedSkill === 'move') ? `ring-2 ring-yellow-400` : ''} text-white p-2 flex items-center flex-col text-xs font-semibold">${moveSkill.icon} ${moveSkill.name}</button>`;
            }
            selectedChar.skills.forEach(id => {
                const skill = SKILLS[id];
                if (!skill || skill.id === 'move') return;
                const isHealSupport = skill.category === 'Heal' || skill.category === 'Support';
                const ringColor = isHealSupport ? 'ring-green-400' : 'ring-red-400';
                html += `<button data-skill-id="${skill.id}" class="skill-btn ${selectedSkill === skill.id ? `ring-2 ${ringColor}` : ''} text-white p-2 flex items-center flex-col text-xs font-semibold">${skill.icon} ${skill.name}</button>`;
            });
            html += `</div>`;
            html += `<button id="end-admin-preview-btn" class="w-full mt-4 bg-gray-500 hover:bg-gray-600 text-white p-2">미리보기 종료</button>`;
            skillControls.innerHTML = html;
            document.getElementById('end-admin-preview-btn').onclick = () => {
                selectedCharacterId = null;
                previewCharacterId = null;
                render();
            };
            document.querySelectorAll('.skill-btn').forEach(btn => btn.onclick = (e) => {
                selectedSkill = e.currentTarget.dataset.skillId;
                render();
            });
            return;
        }

        // 기본 상태 UI
        skillControls.innerHTML = `<p class="text-sm text-gray-400 mt-4">행동할 아군을 선택하세요.</p>`;
    }
}
}
    function updateCharacterList() {
    const listContent = document.getElementById('char-list-content');
    listContent.innerHTML = '';
    
    const remainingPC = characters.filter(c => c.type === 'PC' && c.hp > 0 && c.x !== null).length;
    const remainingEnemy = characters.filter(c => c.type === 'ENEMY' && c.hp > 0 && c.x !== null).length;

    document.getElementById('pc-count').textContent = remainingPC;
    document.getElementById('enemy-count').textContent = remainingEnemy;

    if (!gameId || characters.length === 0) {
        listContent.innerHTML = `<p class="text-sm text-gray-400">캐릭터 로딩 중...</p>`;
        return;
    }
    
    characters.sort((a, b) => a.name.localeCompare(b.name, 'ko'));

    characters.forEach(char => {
        const isActionablePC = roundPhase === 'PLAYER_PHASE' && char.type === 'PC' && !char.hasActedThisRound && char.hp > 0 && char.x !== null;

        const charItem = document.createElement('div');
        charItem.className = `p-2 rounded-md flex flex-col cursor-pointer ${char.id === selectedCharacterId ? 'ring-2 ring-green-400' : 'hover:bg-gray-800'}`;
        
        let statusColor = char.hp <= 0 ? 'text-gray-500' : (char.type === 'ENEMY' ? 'text-red-400' : 'text-gray-300');
        if (isActionablePC) statusColor = 'text-yellow-400';

        charItem.innerHTML = `
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-2">
                    <img src="${char.imageUrl || `https://placehold.co/32x32/1f2937/a0aec0?text=${char.name.charAt(0)}`}" class="w-8 h-8 rounded-full object-cover">
                    <span class="font-semibold truncate">${char.name}</span>
                </div>
                <div class="flex items-center gap-2">
                    <span class="text-xs ${statusColor}">${char.hp <= 0 ? '사망' : (char.x !== null ? `HP: ${char.hp}/${char.maxHp}` : '미배치')}</span>
                </div>
            </div>
        `;
        
        charItem.onclick = () => {
            if ((isActionablePC && canControlCharacter(char.id)) || (isAdmin && char.type === 'PC')) {
                const fakeEvent = { target: document.querySelector(`[data-char-id="${char.id}"]`) };
                handleCombatClick(fakeEvent);
            }
        };
        listContent.appendChild(charItem);
    });
}

    async function deleteCharacter(charId, charName) {
        if (gameId) {
            await deleteDoc(doc(db, 'games', gameId, 'characters', charId));
            await logAction(`🔥 관리자가 **${charName}** 캐릭터를 삭제했습니다.`, "admin");
            // Reset selected character if it was the one deleted
            if (selectedCharacterId === charId) selectedCharacterId = null;
            if (loggedInCharId === charId) handleLogout();
        }
    }
    async function copyCharacter(charToCopy) {
    if (!gameId || !isAdmin) {
        showCustomModal("권한 오류", "캐릭터 복사는 관리자만 가능합니다.", [{ text: "확인", class: "bg-red-600" }]);
        return;
    }

    const { id, ...charData } = charToCopy;
    
    const newCharData = {
        ...charData,
        name: `${charToCopy.name} (복사본)`,
        x: null,
        y: null,
        isLoggedIn: false, 
        hasActedThisRound: false, 
        nextAction: null 
    };
    
    try {
        await addDoc(collection(db, "games", gameId, "characters"), newCharData);
        
        await logAction(`✨ 관리자가 '${charToCopy.name}' 캐릭터를 복사했습니다.`, "admin");
        closeModal('profile-modal'); // 현재 프로필 창 닫기
        showCustomModal("복사 완료", `'${newCharData.name}' 캐릭터가 생성되었습니다.`, [{ text: "확인", class: "bg-green-600" }]);
    } catch (error) {
        console.error("캐릭터 복사 실패:", error);
        showCustomModal("오류", "캐릭터를 복사하는 중 오류가 발생했습니다.", [{ text: "확인", class: "bg-red-600" }]);
    }
}

    
    async function deleteSkill(skillId, skillName) {
        if (!gameId || !isAdmin) return;

        // 1. 이 스킬을 가지고 있는 모든 캐릭터의 스킬 목록에서 해당 스킬 ID를 제거합니다.
        const charUpdateBatch = writeBatch(db);
        let isAnyCharUpdated = false;
        characters.forEach(char => {
            if (char.skills && char.skills.includes(skillId)) {
                isAnyCharUpdated = true;
                const newCharSkills = char.skills.filter(s => s !== skillId);
                const charRef = doc(db, 'games', gameId, 'characters', char.id);
                charUpdateBatch.update(charRef, { skills: newCharSkills });
            }
        });
        
        if (isAnyCharUpdated) {
            await charUpdateBatch.commit();
        }


        const gameDocRef = doc(db, 'games', gameId);
        await updateDoc(gameDocRef, {
            [`skills.${skillId}`]: deleteField()
        });
        
        await logAction(`🔥 관리자가 **${skillName}** 스킬을 삭제했습니다.`, "admin");
        if (selectedSkill === skillId) selectedSkill = null;
        
        closeModal('admin-modal');
        showCustomModal("삭제 완료", `**${skillName}** 스킬이 성공적으로 삭제되었습니다.`, [{ text: "확인", class: "bg-green-600" }]);
    }


    function renderLogs(logs) {
        const logList = document.getElementById('game-log-list');
        logList.innerHTML = logs.map(log => {
            const timeString = log.timestamp ? `[${log.timestamp.toDate().toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' })}] ` : '';
            return `<li class="log-${log.type}">${timeString}${log.message}</li>`;
        }).join('') || `<li class="log-system">아직 기록된 행동이 없습니다.</li>`;
    }
    function renderForeshadowRanges() {
    document.querySelectorAll('.combat-range, .threat-range-foreshadow').forEach(cell => cell.classList.remove('combat-range', 'attack-range-move', 'attack-range-skill', 'heal-range-skill', 'threat-range-foreshadow'));

    if (gameState !== 'STARTED' || roundPhase !== 'ENEMY_FORESHADOW') {
        return;
    }

    const totalThreatCells = new Set();
    const foreshadowingEnemies = characters.filter(c => c.nextAction && c.hp > 0);

    foreshadowingEnemies.forEach(char => {
        const skillId = char.nextAction.skillId;
        if (!SKILLS[skillId] || skillId === 'move') return;

        const skill = SKILLS[skillId];
        const moveSkill = SKILLS['move'];

        const moveRange = char.moveRange !== undefined ? char.moveRange : (moveSkill?.range || 0);
        const reachableMoveCells = new Set();
        reachableMoveCells.add(`${char.x},${char.y}`);

        if (moveRange > 0) {
            for (let dy = -moveRange; dy <= moveRange; dy++) {
                for (let dx = -moveRange; dx <= moveRange; dx++) {
                    if (Math.abs(dx) + Math.abs(dy) <= moveRange) {
                        const moveX = char.x + dx;
                        const moveY = char.y + dy;
                        if (canPlaceCharacter(char, moveX, moveY)) {
                            reachableMoveCells.add(`${moveX},${moveY}`);
                        }
                    }
                }
            }
        }

        const skillRange = skill.range;
        const skillShape = skill.rangeShape || 'diamond';
        const charSize = char.size || 1;

        reachableMoveCells.forEach(cellCoord => {
            const [moveX, moveY] = cellCoord.split(',').map(Number);

            for (let ex = 0; ex < charSize; ex++) {
                for (let ey = 0; ey < charSize; ey++) {
                    const originX = moveX + ex;
                    const originY = moveY + ey;

                    for (let dy = -skillRange; dy <= skillRange; dy++) {
                        for (let dx = -skillRange; dx <= skillRange; dx++) {
                            let inShape = (skillShape === 'diamond' && Math.abs(dx) + Math.abs(dy) <= skillRange) ||
                                          (skillShape === 'square' && Math.abs(dx) <= skillRange && Math.abs(dy) <= skillRange) ||
                                          (skillShape === 'cross' && ((dx === 0 && Math.abs(dy) <= skillRange) || (dy === 0 && Math.abs(dx) <= skillRange)));
                            
                            if (inShape) {
                                const targetX = originX + dx;
                                const targetY = originY + dy;
                                if (targetX >= 0 && targetX < BOARD_SIZE && targetY >= 0 && targetY < BOARD_SIZE) {
                                    totalThreatCells.add(`${targetX},${targetY}`);
                                }
                            }
                        }
                    }
                }
            }
        });
    });

    totalThreatCells.forEach(coord => {
        const [x, y] = coord.split(',');
        const cell = document.querySelector(`.cell[data-x='${x}'][data-y='${y}']`);
        if (cell) cell.classList.add('threat-range-foreshadow');
    });
}
function renderLoginStatus() {
    const list = document.getElementById('login-status-list-modal'); 
    if (!loginStatusBtn || !list) return; 

    if (!isAdmin) {
        loginStatusBtn.classList.add('hidden');
        return;
    }

    loginStatusBtn.classList.remove('hidden'); 

    const pcs = characters.filter(c => c.type === 'PC');
    if (pcs.length === 0) {
        list.innerHTML = `<li class="text-gray-500">플레이어 캐릭터가 없습니다.</li>`;
        return;
    }

    list.innerHTML = pcs.map(pc => {
        const statusIcon = pc.isLoggedIn ? '🟢' : '🔴';
        const statusText = pc.isLoggedIn ? '온라인' : '오프라인';
        const textColor = pc.isLoggedIn ? 'text-green-400' : 'text-gray-500';
        return `<li class="flex justify-between items-center p-2 rounded hover:bg-gray-700/50">
                    <span>${pc.name}</span>
                    <span class="${textColor} font-semibold">${statusIcon} ${statusText}</span>
                </li>`;
    }).join('');
}
   function render() {
    if (!isBoardInitialized) initializeBoard();

    document.querySelectorAll('.cell').forEach(cell => {
        cell.innerHTML = '';
        cell.classList.remove('tile-obstacle', 'tile-damage', 'combat-range', 'attack-range-move', 'attack-range-skill', 'heal-range-skill', 'threat-range-foreshadow');
        const x = parseInt(cell.dataset.x), y = parseInt(cell.dataset.y);
        const tile = boardTiles[`${x},${y}`];
        if (tile) cell.classList.add(`tile-${tile.type}`);
    });

    gameBoard.style.backgroundImage = boardBackgroundImage ? `url('${boardBackgroundImage}')` : 'none';

    updateAuthStatus();

    characters.filter(char => char.x !== null).forEach(char => {
        const cell = gameBoard.querySelector(`.cell[data-x='${char.x}'][data-y='${char.y}']`);
        if (cell) {
            if (char.id === previewCharacterId) {
                const ghostToken = document.createElement('div');
                ghostToken.className = `character-token ghost-preview-token ${char.type === 'ENEMY' ? 'enemy-token' : ''}`;
                ghostToken.style.width = `${char.size * 100}%`;
                ghostToken.style.height = `${char.size * 100}%`;
                if (char.imageUrl) {
                    ghostToken.style.backgroundImage = `url('${char.imageUrl}')`;
                } else {
                    ghostToken.innerHTML = `<span class="token-placeholder font-title">${char.name.charAt(0)}</span>`;
                }
                cell.appendChild(ghostToken);
                return;
            }

             const token = document.createElement('div');
            token.className = 'character-token';
            token.style.width = `${char.size * 100}%`;
            token.style.height = `${char.size * 100}%`;
                        const isActingPC = (char.id === selectedCharacterId && char.type === 'PC');
            const isMyLargeCharMoving = (char.id === selectedCharacterId && selectedSkill === 'move' && char.size > 1);
            let isTargetingLargeEnemy = false;
            const attacker = characters.find(c => c.id === selectedCharacterId);
            const currentSkill = SKILLS[selectedSkill];
            if (attacker && currentSkill?.category === 'Attack' && char.size > 1 && char.type !== attacker.type) {
                isTargetingLargeEnemy = true;
            }

            if (isActingPC || isMyLargeCharMoving || isTargetingLargeEnemy) {
                token.classList.add('token-click-through');
            }
            if (char.type === 'ENEMY') token.classList.add('enemy-token');
            if (char.id === selectedCharacterId || char.id === adminSelectedEnemyId) token.classList.add('selected-character');
            const isActionablePC = char.type === 'PC' && gameState === 'STARTED' && roundPhase === 'PLAYER_PHASE' && !char.hasActedThisRound;
            if (isActionablePC) {
                token.classList.add('current-turn-glow');
                const marker = document.createElement('div');
                marker.className = 'turn-marker';
                marker.innerHTML = '▼';
                token.appendChild(marker);
            }

            const isWaitingEnemy = char.type === 'ENEMY' && roundPhase === 'ENEMY_EXECUTION' && char.nextAction != null;
            if (isWaitingEnemy) {
                token.classList.add('enemy-turn-glow');
                const marker = document.createElement('div');
                marker.className = 'enemy-turn-marker';
                marker.innerHTML = '▼';
                token.appendChild(marker);
            }

            if (char.hp <= 0) token.style.filter = 'grayscale(100%) opacity(0.5)';
            token.dataset.charId = char.id;
            if (char.imageUrl) {
                token.style.backgroundImage = `url('${char.imageUrl}')`;
            } else {
                const placeholder = document.createElement('span');
                placeholder.className = 'token-placeholder font-title';
                placeholder.textContent = char.name.charAt(0);
                token.appendChild(placeholder);
            }
            const hpPercent = (char.hp / char.maxHp) * 100;
            const mpPercent = (char.mp / char.maxMp) * 100;
            const barContainer = document.createElement('div');
            barContainer.className = 'hp-mp-bar-container';
            barContainer.innerHTML = `<div class="hp-bar"><div class="hp-fill" style="width: ${hpPercent}%;"></div></div><div class="mp-bar"><div class="mp-fill" style="width: ${mpPercent}%;"></div></div>`;
            token.appendChild(barContainer);

            if (char.nextAction && char.hp > 0) {
                const bubble = document.createElement('div');
                bubble.className = 'action-speech-bubble';
                const skill = SKILLS[char.nextAction.skillId];
                bubble.textContent = skill ? skill.name : '행동 준비...';
                token.appendChild(bubble);
            }

            if (char.statusEffects && char.statusEffects.length > 0) {
                char.statusEffects.forEach((effect, index) => {
                    const icon = STATUS_EFFECT_ICONS[effect.id];
                    if (icon) {
                        const iconEl = document.createElement('span');
                        iconEl.className = 'status-effect-icon';
                        iconEl.innerHTML = icon;
                        iconEl.title = `${effect.name} (${effect.turnsRemaining}턴 남음)`;
                        iconEl.style.right = `${-5 + (index * 20)}px`;
                        token.appendChild(iconEl);
                    }
                });
            }

            cell.appendChild(token);
        }
    });

    const turnStatusDiv = document.getElementById('current-turn-char');
    const turnStatusTitle = document.querySelector('#turn-status p');

    if (gameState === 'PREPARATION') {
        turnStatusTitle.textContent = "게임 상태:";
        turnStatusDiv.textContent = `준비 단계`;
        turnStatusDiv.style.color = 'var(--text-secondary)';
    } else {
        turnStatusTitle.textContent = `Round ${round}`;
        if (roundPhase === 'PLAYER_PHASE') {
            turnStatusDiv.textContent = `아군 턴`;
            turnStatusDiv.style.color = '#34d399';
        } else {
            turnStatusDiv.textContent = `적 턴`;
            turnStatusDiv.style.color = '#f87171';
        }
    }

    if (roundPhase === 'ENEMY_EXECUTION' && foreshadowingAction) {
        const actingChar = characters.find(c => c.id === foreshadowingAction.charId);
        if (actingChar) {
            highlightRange(actingChar, foreshadowingAction.skillId);
        }
    }
    else if (roundPhase === 'ENEMY_FORESHADOW') {
        renderForeshadowRanges();
    }
    else {
        const charForUi = characters.find(c => c.id === selectedCharacterId || c.id === previewCharacterId);
        if (gameState === 'STARTED' && charForUi) {
            highlightRange(charForUi, selectedSkill || 'move');
        }
    }

    const charForUi = characters.find(c => c.id === selectedCharacterId || c.id === previewCharacterId);
    renderSkillButtons(charForUi);

    const adminTurnControls = document.getElementById('admin-turn-controls');
    adminTurnControls.innerHTML = '';

    if (isAdmin && gameState === 'STARTED' && roundPhase === 'PLAYER_PHASE') {
        adminTurnControls.innerHTML = `
            <button id="admin-end-player-phase-btn" class="w-full bg-yellow-600 hover:bg-yellow-700 text-black p-2 font-bold text-sm rounded-md">
                ⏭ 아군 턴 강제 종료
            </button>
        `;
        document.getElementById('admin-end-player-phase-btn').onclick = async () => {
            await logAction('⏭ 관리자가 아군 턴을 강제로 종료했습니다.', 'admin');
            await advanceRoundPhase();
        };
    }
    updateCharacterList();
    renderLoginStatus();
    renderCharacterSelectionOverlay();
    renderForeshadowing();
}

    async function removeCharacterPlacement(charId, charName) {
        if (gameId) {
            await updateDoc(doc(db, 'games', gameId, 'characters', charId), { x: null, y: null });
            await logAction(`↩️ ${charName}이(가) 보드에서 배치 해제되었습니다.`, "admin");
            if (selectedCharacterId === charId) selectedCharacterId = null;
            closeModal('profile-modal');
            render();
        }
    }


    window.openProfileModal = (charId) => openProfileModal(characters.find(c => c.id === charId));
    
    function openProfileModal(character, editMode = false) {
        if (!character) return;
        const contentContainer = profileModal.querySelector('#modal-content');
        const isEnemy = character.type === 'ENEMY';
        
        // Authorization Check for action buttons in profile modal
        const canUnplace = isAdmin || (loggedInCharId === character.id && character.type === 'PC' && gameState === 'PREPARATION');
        
        if (editMode) {
            // Admin Edit Mode
             const skillOptions = Object.values(SKILLS); // Include all skills now
            const skillSelects = [1, 2, 3, 4, 5].map(index => { // Increased skill slots for management
                const currentSkill = character.skills?.[index - 1] || 'none';
                return `<div><label class="text-sm text-gray-400">스킬 ${index}</label><select id="edit-skill-${index}" class="form-input mt-1"><option value="none">-- 없음 --</option>${skillOptions.map(skill => `<option value="${skill.id}" ${skill.id === currentSkill ? 'selected' : ''}>${skill.name} (${skill.category})</option>`).join('')}</select></div>`;
            }).join('');
            
            const currentMoveRange = character.moveRange !== undefined 
                ? character.moveRange 
                : SKILLS['move']?.range || 1; // Default to 1
            
            contentContainer.innerHTML = `<div class="profile-modal-container rounded-lg ${isEnemy ? 'enemy-profile' : ''}" style="grid-template-columns: 1fr;">
                <div class="p-6">
                    <div class="flex justify-between items-center mb-6"><h3 class="text-2xl font-bold font-title text-accent-primary">수정: ${character.name}</h3><button id="close-modal-btn" class="hover:text-white text-3xl leading-none">&times;</button></div>
                    <div class="space-y-4 max-h-[70vh] overflow-y-auto pr-4">
                        <div><label class="text-gray-400">이름</label><input id="edit-name" class="form-input mt-1" value="${character.name}"></div>
                        <div><label class="text-gray-400">이미지 URL</label><input id="edit-image-url" class="form-input mt-1" value="${character.imageUrl || ''}"></div>
                        ${character.type === 'PC' ? `<div><label class="text-gray-400">PC 비밀번호</label><input id="edit-password" type="text" class="form-input mt-1" value="${character.password || DEFAULT_PC_PASSWORD}"></div>` : ''}
                        <div class="grid grid-cols-3 gap-4">
                            <div><label class="text-gray-400">HP</label><input id="edit-hp" type="number" class="form-input mt-1" value="${character.hp}"></div><div><label class="text-gray-400">최대 HP</label><input id="edit-max-hp" type="number" class="form-input mt-1" value="${character.maxHp}"></div>
                            <div><label class="text-gray-400">MP</label><input id="edit-mp" type="number" class="form-input mt-1" value="${character.mp}"></div><div><label class="text-gray-400">최대 MP</label><input id="edit-max-mp" type="number" class="form-input mt-1" value="${character.maxMp}"></div>
                            <div><label class="text-gray-400">최소 공격력</label><input id="edit-min-attack" type="number" class="form-input mt-1" value="${character.minAttack}"></div><div><label class="text-gray-400">최대 공격력</label><input id="edit-max-attack" type="number" class="form-input mt-1" value="${character.maxAttack}"></div>
                            <div><label class="text-gray-400">최소 방어력</label><input id="edit-min-defense" type="number" class="form-input mt-1" value="${character.minDefense}"></div><div><label class="text-gray-400">최대 방어력</label><input id="edit-max-defense" type="number" class="form-input mt-1" value="${character.maxDefense}"></div>
                            <div><label class="text-gray-400">크기 (예: 1, 2)</label><input id="edit-size" type="number" class="form-input mt-1" value="${character.size || 1}"></div>
                        </div>
                        <div class="flex items-center gap-2 pt-4 border-t border-gray-700/50">
                        </div>
                        <h4 class="text-lg font-bold text-gray-300 pt-4">스킬 선택</h4>
                        <div class="grid grid-cols-3 gap-4">${skillSelects}</div>
                         
                        ${character.skills.includes('move') ? 
                            `
                            <h4 class="text-lg font-bold text-gray-300 pt-4 border-t border-gray-700/50">행동력 조정</h4>
                            <div>
                                <label class="text-gray-400">이동력 ('move' 스킬 범위)</label>
                                <input id="edit-move-range" type="number" class="form-input mt-1" value="${currentMoveRange}">
                            </div>
                            ` : ''}
                    </div>
                    <div class="mt-8 flex gap-4 flex-shrink-0">
                       <button id="save-changes-btn" class="w-full bg-green-600 font-bold py-3">저장</button><button id="cancel-edit-btn" class="w-full bg-gray-600 font-bold py-3">취소</button>
                    </div>
                </div>
            </div>`;
            
            document.getElementById('save-changes-btn').onclick = async () => {
                const updates = { 
                    name: document.getElementById('edit-name').value, 
                    imageUrl: document.getElementById('edit-image-url').value.trim(), 
                    hp: parseInt(document.getElementById('edit-hp').value), 
                    maxHp: parseInt(document.getElementById('edit-max-hp').value), 
                    mp: parseInt(document.getElementById('edit-mp').value), 
                    maxMp: parseInt(document.getElementById('edit-max-mp').value), 
                    minAttack: parseInt(document.getElementById('edit-min-attack').value),
                    maxAttack: parseInt(document.getElementById('edit-max-attack').value),
                    minDefense: parseInt(document.getElementById('edit-min-defense').value),
                    maxDefense: parseInt(document.getElementById('edit-max-defense').value),
                    size: parseInt(document.getElementById('edit-size').value) || 1,
                    
                    skills: [
                        document.getElementById('edit-skill-1').value, 
                        document.getElementById('edit-skill-2').value, 
                        document.getElementById('edit-skill-3').value,
                        document.getElementById('edit-skill-4').value,
                        document.getElementById('edit-skill-5').value
                    ].filter(s => s && s !== 'none') 
                };
                if (character.type === 'PC') updates.password = document.getElementById('edit-password').value;
                // NEW: Update 'move' skill range for this specific character if changed.
                if (character.skills.includes('move')) {
                    const newMoveRange = parseInt(document.getElementById('edit-move-range').value) || 1;
                    updates.moveRange = newMoveRange;
                }
                
                if (gameId) await updateDoc(doc(db, 'games', gameId, 'characters', character.id), updates);
                openProfileModal({...character, ...updates}, false);
            };
            document.getElementById('cancel-edit-btn').onclick = () => openProfileModal(character, false);
          } else {
        const statIcon = (type) => ({
            hp: `<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"></path></svg>`,
            defense: `<svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 2L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-3z" /></svg>`,
mp: `<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 2.25c-5.385 5.965-8.25 10.561-8.25 14.25a8.25 8.25 0 1016.5 0c0-3.689-2.865-8.285-8.25-14.25z"></path></svg>`,        }[type] || '');
        const attackIconSvg = `<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19.4 4.6a2 2 0 0 0-2.8 0l-9.5 9.5-3.5-1.5a1 1 0 0 0-1.1.2l-1.3 1.3a1 1 0 0 0 0 1.4l2.6 2.6-2.1 2.1a1 1 0 1 0 1.4 1.4l2.1-2.1 2.6 2.6a1 1 0 0 0 1.4 0l1.3-1.3a1 1 0 0 0 .2-1.1l-1.5-3.5 9.5-9.5a2 2 0 0 0 0-2.8z"></path></svg>`;
        
        const sizeIconSvg = `<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="3" y1="15" x2="21" y2="15"></line><line x1="9" y1="3" x2="9" y2="21"></line><line x1="15" y1="3" x2="15" y2="21"></line></svg>`;
        const moveIconSvg = `<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>`;
        
        const buildStat = (type, label, value) => {
            let iconHtml = statIcon(type);
            if (type === 'attack') iconHtml = attackIconSvg;
            if (type === 'size') iconHtml = sizeIconSvg;
            if (type === 'move') iconHtml = moveIconSvg;
            return `<div class="stat-item">${iconHtml}<div><div class="value">${value}</div><div class="label">${label}</div></div></div>`;
        }
        
        const effectiveMoveRange = character.moveRange !== undefined 
            ? character.moveRange 
            : SKILLS['move']?.range || 1;

        contentContainer.innerHTML = `<div class="profile-modal-container rounded-lg ${isEnemy ? 'enemy-profile' : ''}">
            <button id="close-modal-btn" class="hover:text-white text-3xl leading-none">&times;</button>
            <div class="profile-char-image"></div>
            <div class="profile-stats-panel">
                <div class="profile-content-scroll">
                    <div>
                        <h2 class="profile-char-name font-title">${character.name}</h2>
                        <p class="profile-char-type">${character.type}</p>
                        <div class="profile-stats-grid">
                            ${buildStat('hp', '생명력', `${character.hp} / ${character.maxHp}`)}
                            ${buildStat('mp', '마나', `${character.mp} / ${character.maxMp}`)}
                            ${buildStat('attack', '공격력', `${character.minAttack} - ${character.maxAttack}`)}
                            ${buildStat('defense', '방어력', `${character.minDefense} - ${character.maxDefense}`)}
                            ${buildStat('move', '이동력', `${effectiveMoveRange} 칸`)}
                            ${buildStat('size', '크기', `${character.size}x${character.size}`)}
                        </div>
                    </div>
                    <div class="mt-6">
                        <h3 class="text-xl font-bold mb-3">보유 스킬</h3>
                        <div class="space-y-2">
                            ${character.skills.map(id => SKILLS[id]).filter(Boolean).map(s => {
                                let costText = "";
                                if (s.mpCost > 0) costText += `${s.mpCost} MP `;
                                if (s.hpCost > 0) costText += `${s.hpCost} HP `;
                                return `<div class="p-3 bg-gray-800/50 rounded-md flex items-center gap-3">
                                    <span class="text-2xl">${s.icon}</span>
                                    <div>
                                        <strong>${s.name} <span class="text-xs text-gray-500">(${s.category})</span></strong>
                                        <small class="block text-gray-400">
                                            ${s.isAoe ? `광역(범위: ${s.aoeRange})` : `단일`}, 사거리: ${s.range}
                                            ${costText ? `| 비용: ${costText}` : ''}
                                        </small>
                                    </div>
                                </div>`;
                            }).join('') || '<p class="text-gray-500">보유 스킬이 없습니다.</p>'}
                        </div>
                    </div>
                    
                    <div class="mt-6" id="status-effects-section">
                        <h3 class="text-xl font-bold mb-3">상태 효과</h3>
                        <div class="space-y-2">
                            ${(character.statusEffects && character.statusEffects.length > 0) ? 
                                character.statusEffects.map((effect, index) => `
                                    <div class="p-3 bg-gray-800/50 rounded-md flex items-center justify-between gap-3">
                                        <div class="flex items-center gap-2">
                                            <span class="text-2xl">${STATUS_EFFECT_ICONS[effect.id] || '🔗'}</span>
                                            <div>
                                                <strong>${effect.name}</strong>
                                                <small class="block text-gray-400">
                                                    남은 턴: ${effect.turnsRemaining}
                                                    ${effect.value ? ` | 값: ${effect.value}` : ''}
                                                </small>
                                            </div>
                                        </div>
                                        ${isAdmin ? `<button class="remove-effect-btn text-red-500 hover:text-red-300 p-2 leading-none" data-effect-index="${index}">❌</button>` : ''}
                                    </div>
                                `).join('')
                                : '<p class="text-gray-500">걸려 있는 효과가 없습니다.</p>'
                            }
                        </div>
                    </div>
                    </div>
                   <div class="mt-auto pt-4 flex-shrink-0 space-y-3">
                       <button id="edit-char-btn" class="w-full bg-gray-600 hover:bg-gray-700 font-bold py-3 px-4">캐릭터 수정</button>
                       ${(character.x !== null && canUnplace) ? `<button id="unplace-char-btn" class="w-full bg-yellow-700 hover:bg-yellow-600 font-bold py-3 px-4">보드에서 배치 해제</button>` : ''}
                       ${isAdmin ? `
                        <div class="flex gap-2">
                           <button id="delete-char-btn" class="w-full bg-red-900 hover:bg-red-800 font-bold py-3 px-4">영구 삭제</button>
                           <button id="copy-char-btn" class="w-full bg-blue-600 hover:bg-blue-700 font-bold py-3 px-4">캐릭터 복사</button>
                        </div>
                       ` : ''}
                    </div>
            </div>
        </div>`;
        
        const imageContainer = contentContainer.querySelector('.profile-char-image');
        if (character.imageUrl) {
            imageContainer.style.backgroundImage = `url('${character.imageUrl}')`;
        } else {
            imageContainer.style.backgroundImage = 'none';
            imageContainer.classList.add('flex', 'items-center', 'justify-center');
            imageContainer.innerHTML = `<span class="font-title text-9xl text-gray-600">${character.name.charAt(0)}</span>`;
        }
        
        document.getElementById('edit-char-btn').onclick = () => {
            if (isAdmin) {
                openProfileModal(character, true);
            } else {
                showCustomModal("권한 부족", "캐릭터 정보 수정은 관리자만 가능합니다.", [{text:"확인", class:"bg-red-600"}]);
            }
        };
        
         const deleteBtn = document.getElementById('delete-char-btn');
            if (deleteBtn) {
                deleteBtn.onclick = () => {
                    showCustomModal(
                        "캐릭터 삭제 확인",
                        `정말로 **${character.name}** 캐릭터를 영구적으로 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.`,
                        [
                            { text: "취소", class: "bg-gray-600" },
                            { 
                                text: "삭제", 
                                class: "bg-red-600", 
                                onClick: () => {
                                    deleteCharacter(character.id, character.name);
                                    closeModal('profile-modal'); // 삭제 후 모달 닫기
                                }
                            }
                        ]
                    );
                };
            }
            const copyBtn = document.getElementById('copy-char-btn');
            if (copyBtn) {
                copyBtn.onclick = () => copyCharacter(character);
            }

        if (isAdmin) {
            document.querySelectorAll('.remove-effect-btn').forEach(button => {
                button.onclick = async (e) => {
                    const effectIndex = parseInt(e.currentTarget.dataset.effectIndex);
                    const updatedEffects = [...character.statusEffects];
                    const removedEffect = updatedEffects.splice(effectIndex, 1)[0];

                    if (gameId && removedEffect) {
                        await updateDoc(doc(db, 'games', gameId, 'characters', character.id), {
                            statusEffects: updatedEffects
                        });
                        await logAction(`✅ 관리자가 ${character.name}의 [${removedEffect.name}] 효과를 삭제했습니다.`, "admin");
                        
                        openProfileModal({ ...character, statusEffects: updatedEffects });
                    }
                };
            });
        }
    }
    const unplaceBtn = document.getElementById('unplace-char-btn');
if (unplaceBtn) {
    unplaceBtn.onclick = () => {
        // 보드 배치 해제 함수를 호출
        removeCharacterPlacement(character.id, character.name);
    };
}
    profileModal.classList.remove('hidden');
    document.getElementById('close-modal-btn').onclick = () => closeModal('profile-modal');
}
    function closeModal(modalId) { document.getElementById(modalId).classList.add('hidden'); }
    
    // --- Admin Functions ---
    
    async function resetBoardPositions() {
        if (!gameId) return;
        const batch = writeBatch(db);
        characters.forEach(char => {
            const charRef = doc(db, 'games', gameId, 'characters', char.id);
            batch.update(charRef, { x: null, y: null });
        });
        await batch.commit();
        await logAction(`🔄 관리자가 모든 캐릭터를 미배치 상태로 되돌렸습니다.`, "admin");
        selectedCharacterId = null;
        render();
    }
async function resetAllCharacterStats() {
        if (!gameId) return;
        
        const charCollectionRef = collection(db, "games", gameId, "characters");
        const snapshot = await getDocs(charCollectionRef);
        
        if (!snapshot.empty) {
            const batch = writeBatch(db);
            snapshot.docs.forEach(charDoc => {
                const charData = charDoc.data();
                batch.update(charDoc.ref, {
                    hp: charData.maxHp, // 현재 HP를 최대 HP로 설정
                    mp: charData.maxMp, // MP도 최대 MP로 설정
                    x: null,             // 보드에서 배치 해제
                    y: null,
                    statusEffects: [],   // 모든 상태 효과(버프/디버프)도 제거
                    nextAction: deleteField() // ❗️ [추가] 예고된 행동 정보를 삭제합니다.
                });
            });
            await batch.commit();
            console.log('All character stats, status effects, and positions have been reset.');
        }
    }

    async function resetAllGameData() {
    if (!gameId) return;

    await resetAllCharacterStats();
    await setDoc(doc(db, 'games', gameId, 'board', 'tiles'), { tiles: {} });
    await setDoc(doc(db, 'games', gameId), { 
        gameState: 'PREPARATION', 
        currentTurnIndex: 0, 
        currentTurnCharId: null, 
        round: 1,
        roundPhase: null, 
        gameResult: deleteField() 
    }, { merge: true });

    await logAction(`⚠️ 관리자가 전체 게임을 초기화했습니다. 모든 캐릭터의 HP가 회복되고 재배치를 기다립니다.`, "admin");
}


    function confirmExitMapEditMode() {
        isMapEditMode = false; // Mode OFF
        closeModal('map-edit-modal');
        logAction(`🗺️ 관리자가 맵 편집 모드를 종료했습니다.`, "admin");
        updateAuthStatus();
    }

    function hideMapEditModalTemporarily() {
        closeModal('map-edit-modal');
        updateAuthStatus();
    }
    
    function openMapEditModal() {
        if (!isAdmin || gameState !== 'PREPARATION') {
             showCustomModal("권한 오류", "맵 편집은 관리자만, 그리고 게임 준비 단계에서만 가능합니다.", [{text:"확인", class:"bg-red-600"}]);
             return;
        }

        closeModal('admin-modal'); 

        isMapEditMode = true;
        currentTileType = 'normal';
        mapEditModal.classList.remove('hidden');
        document.getElementById('map-edit-status').textContent = '현재 선택: 일반 칸';
        updateAuthStatus();
    }

    async function saveBoardTile(x, y, type) {
        if (!gameId) return;
        const tileKey = `${x},${y}`;
        const newTiles = { ...boardTiles };

        if (type === 'normal') {
            delete newTiles[tileKey];
        } else {
            newTiles[tileKey] = { type };
        }
        
        await setDoc(doc(db, 'games', gameId, 'board', 'tiles'), { tiles: newTiles });
        await logAction(`🗺️ 관리자가 (${x}, ${y}) 칸을 ${type === 'obstacle' ? '장애물(🚫)' : (type === 'damage' ? '대미지 칸(🩸)' : '일반 칸')}으로 설정했습니다.`, "admin");
    }
    
    // NEW: Save Background Image
    async function saveBoardBackground(url) {
        if (!gameId) return;
        await setDoc(doc(db, 'games', gameId), { boardBackgroundImage: url }, { merge: true });
        boardBackgroundImage = url;
        await logAction(`🖼️ 관리자가 보드 배경을 설정했습니다.`, "admin");
    }


      function openAdminModal() {
        if (!gameId) return;

        closeModal('map-edit-modal'); 
        
        const container = document.getElementById('admin-modal-content');
        
        // --- 1. 모든 HTML을 하나의 변수에 먼저 만듭니다. ---
        let modalHtml = `<div class="flex justify-between items-center mb-6"><h3 class="text-2xl font-bold font-title" style="color: var(--accent-primary);">관리자 패널</h3><button id="close-admin-modal-btn" class="hover:text-white text-3xl leading-none">&times;</button></div>`;

        modalHtml += `<div class="mb-8 p-4 border border-gray-700 rounded-md">
             <h4 class="font-bold text-lg mb-4 text-yellow-400">게임 진행 관리</h4>
    <div class="grid grid-cols-2 gap-4">
        <button id="set-prep-phase-btn" class="w-full bg-blue-600 p-2">준비 단계로 설정</button>
        <button id="set-start-phase-btn" class="w-full bg-green-600 p-2">게임 시작</button>
        <button id="force-player-phase-btn" class="w-full bg-green-700 p-2">아군 턴으로 강제 전환</button>
        <button id="force-enemy-phase-btn" class="w-full bg-red-700 p-2">적군 턴으로 강제 전환</button>
    </div>
    <div class="mt-4 grid grid-cols-2 gap-4">
        <button id="reset-board-pos-btn" class="w-full bg-red-700 p-2">보드 초기화 (미배치)</button>
        <button id="reset-all-game-btn" class="w-full bg-red-900 p-2">⚠️ 전체 게임 재시작</button>
    </div>
            <div class="mt-4 pt-4 border-t border-gray-700">
                 <button id="clear-log-btn" class="w-full bg-yellow-700 hover:bg-yellow-600 p-2">📜 게임 로그 지우기</button>
            </div>
            <div class="mt-4">
                <label for="max-rounds-input" class="block text-sm font-medium text-gray-300">최대 라운드 (0=무한)</label>
                <div class="flex gap-2 mt-1">
                    <input type="number" id="max-rounds-input" class="form-input" value="${maxRounds}">
                    <button id="save-max-rounds-btn" class="bg-indigo-600 p-2 px-4">저장</button>
                </div>
            </div>
            <div class="mt-4 flex items-center">
                <input type="checkbox" id="admin-move-toggle" class="form-checkbox h-5 w-5 text-purple-600 transition duration-150 ease-in-out" ${isAdminMoveAllowed ? 'checked' : ''}>
                <label for="admin-move-toggle" class="ml-2 block text-sm text-gray-300 font-medium">관리자 토큰 이동 허용 (턴 무시)</label>
            </div>
        </div>`;
        modalHtml += `<div class="mb-8 p-4 border border-gray-700 rounded-md">
    <h4 class="font-bold text-lg mb-4 text-yellow-400">방 설정 저장/불러오기</h4>
    <p class="text-sm text-gray-400 mb-4">현재 게임의 모든 설정(캐릭터, 스킬, 맵 등)을 하나의 파일로 저장하거나, 파일에서 불러와 덮어씌웁니다.</p>
    <div class="grid grid-cols-2 gap-4">
        <button id="save-settings-btn" class="w-full bg-blue-600 p-2">설정 파일로 저장하기</button>
        <button id="load-settings-btn" class="w-full bg-green-600 p-2">파일에서 불러오기</button>
    </div>
    <input type="file" id="load-settings-input" class="hidden" accept=".json">
</div>`;

modalHtml += `<div class="mb-8 p-4 border border-gray-700 rounded-md">
            <h4 class="font-bold text-lg mb-4 text-yellow-400">맵/지형 및 배경 관리</h4>
            <button id="open-map-edit-btn" class="w-full bg-purple-600 p-2 font-bold ${gameState !== 'PREPARATION' ? 'opacity-50 cursor-not-allowed' : ''}" ${gameState !== 'PREPARATION' ? 'disabled' : ''}>맵 편집 모드 ${isMapEditMode ? '종료' : '시작'}</button>
            <div class="mt-4 pt-4 border-t border-gray-700/50">
                <label for="board-bg-url" class="block text-sm font-medium text-gray-300">게임 보드 배경 URL</label>
                <div class="flex gap-2 mt-1">
                    <input type="text" id="board-bg-url" class="form-input flex-grow" placeholder="이미지 URL" value="${boardBackgroundImage}">
                    <button id="save-board-bg-btn" class="bg-indigo-600 p-2 px-4">적용</button>
                </div>
            </div>
            <div class="mt-4 pt-4 border-t border-gray-700/50">
                <label for="page-bg-url" class="block text-sm font-medium text-gray-300">전체 페이지 배경 URL</label>
                <div class="flex gap-2 mt-1">
                    <input type="text" id="page-bg-url" class="form-input flex-grow" placeholder="이미지 URL" value="${pageBackgroundImage}">
                    <button id="save-page-bg-btn" class="bg-indigo-600 p-2 px-4">적용</button>
                </div>
            </div>
        </div>`;

        const skillsByCategory = Object.values(SKILLS).reduce((acc, s) => {
            const category = s.category || 'Other';
            if (!acc[category]) acc[category] = [];
            acc[category].push(s);
            return acc;
        }, {});

        let skillHtml = `<div id="admin-skill-list" class="space-y-6"><h3 class="text-2xl font-bold font-title" style="color: var(--accent-primary);">스킬 목록/편집</h3>`;
        SKILL_CATEGORIES.forEach(category => {
            const skills = skillsByCategory[category];
            if (skills && skills.length > 0) {
                skillHtml += `<div class="mt-4"><h4 class="font-bold text-xl mb-3 text-white border-b border-gray-700 pb-1">${category} 스킬</h4><div class="space-y-3">`;
                skills.sort((a, b) => a.name.localeCompare(b.name)).forEach(s => {
                    const costDisplay = [s.mpCost > 0 ? `${s.mpCost} MP` : '', s.hpCost > 0 ? `${s.hpCost} HP` : ''].filter(Boolean).join(', ');
                    skillHtml += `
                    <div class="bg-gray-800 rounded-md overflow-hidden border border-gray-700">
                        <div class="accordion-header flex justify-between items-center p-3 cursor-pointer hover:bg-gray-700/50 transition-colors">
                            <div>
                                <h4 class="font-bold text-lg">${s.icon} ${s.name} <span class="text-sm text-gray-400">(${s.id})</span></h4>
                                <p class="text-xs text-gray-500 mt-1">비용: ${costDisplay || '없음'} | 범위: ${s.range} | 계수: ${s.multiplier} | 타입: ${s.type}</p>
                            </div>
                            <span class="accordion-icon text-xl transform transition-transform text-gray-400">▼</span>
                        </div>
                        <div class="accordion-content hidden p-4 border-t border-gray-700/50">
                            ${getSkillEditFormHtml(s)}
                        </div>
                    </div>`;
                });
                skillHtml += `</div></div>`;
            }
        });
        skillHtml += `</div>`;
        modalHtml += skillHtml;

        modalHtml += `<div class="mt-8 pt-4 border-t border-gray-700">
            <h4 class="font-bold text-lg mb-2 text-green-400">새 스킬 추가</h4>
            ${getNewSkillFormHtml()}
        </div>`;

        modalHtml += `<div class="mt-8 pt-4 border-t border-gray-700">
            <h4 class="font-bold text-lg mb-2 text-green-400">새 캐릭터/에너미 추가</h4>
            ${getNewCharacterFormHtml()}
        </div>`;


        container.innerHTML = modalHtml;

        const skillListContainer = container.querySelector('#admin-skill-list');
        if (skillListContainer) {
            skillListContainer.addEventListener('click', e => {
                const header = e.target.closest('.accordion-header');
                if (!header) return;
                const content = header.nextElementSibling;
                const icon = header.querySelector('.accordion-icon');
                if (content && content.classList.contains('accordion-content')) {
                    content.classList.toggle('hidden');
                    icon.classList.toggle('rotate-180');
                }
            });
        }
        
        document.getElementById('save-settings-btn').onclick = saveSettingsToFile;
        document.getElementById('load-settings-btn').onclick = () => {
            document.getElementById('load-settings-input').click();
        };
        document.getElementById('load-settings-input').onchange = (e) => {
            const file = e.target.files[0];
            if (file) {
                loadSettingsFromFile(file);
            }
            e.target.value = null;
        };
        
        document.getElementById('close-admin-modal-btn').onclick = () => closeModal('admin-modal');
        document.getElementById('set-prep-phase-btn').onclick = async () => {
            if (gameId) {
                await updateDoc(doc(db, 'games', gameId), { 
                    gameState: 'PREPARATION', 
                    roundPhase: null, 
                    currentTurnIndex: 0, 
                    currentTurnCharId: null, 
                    round: 1 
                });

                const batch = writeBatch(db);
                characters.forEach(char => {
                    const charRef = doc(db, 'games', gameId, 'characters', char.id);
                    batch.update(charRef, { nextAction: deleteField() });
                });
                await batch.commit();

                await logAction(`🛠️ 관리자가 게임을 준비 단계로 설정했습니다.`, "system");
                showCustomModal("상태 변경", "게임이 준비 단계로 설정되었습니다. 자유롭게 토큰을 배치하세요.", [{text: "확인", class: "bg-blue-600"}]);
            }
        };
        document.getElementById('set-start-phase-btn').onclick = async () => {
    if (gameId) {
        await setDoc(doc(db, 'games', gameId), { 
            gameState: 'STARTED',
            roundPhase: 'ENEMY_FORESHADOW' 
        }, { merge: true });

        const batch = writeBatch(db);
        characters.forEach(char => {
            const charRef = doc(db, 'games', gameId, 'characters', char.id);
            batch.update(charRef, { hasActedThisRound: false, nextAction: null });
        });
        await batch.commit();
        
        await logAction(`⚔️ 게임이 시작되었습니다! 라운드 1의 적 행동 예고를 시작합니다.`, "system");
    }
};
document.getElementById('force-player-phase-btn').onclick = async () => {
    if (gameId) {
        await setDoc(doc(db, 'games', gameId), { roundPhase: 'PLAYER_PHASE' }, { merge: true });
        await logAction('⚙️ 관리자가 아군 턴으로 강제 전환했습니다.', 'admin');
        closeModal('admin-modal');
    }
};
document.getElementById('force-enemy-phase-btn').onclick = async () => {
    if (gameId) {
        await setDoc(doc(db, 'games', gameId), { roundPhase: 'ENEMY_EXECUTION' }, { merge: true });
        await logAction('⚙️ 관리자가 적군 턴으로 강제 전환했습니다.', 'admin');
        closeModal('admin-modal');
    }
};
        document.getElementById('save-max-rounds-btn').onclick = async () => {
            if (gameId) {
                const newMaxRounds = parseInt(document.getElementById('max-rounds-input').value) || 0;
                await updateDoc(doc(db, 'games', gameId), { maxRounds: newMaxRounds });
                showCustomModal("설정 저장", `최대 라운드가 ${newMaxRounds > 0 ? newMaxRounds : '무한'}으로 설정되었습니다.`, [{text: "확인", class: "bg-indigo-600"}]);
            }
        };
        document.getElementById('reset-board-pos-btn').onclick = resetBoardPositions;
        document.getElementById('reset-all-game-btn').onclick = () => {
            showCustomModal("전체 초기화 경고", "모든 캐릭터, 맵 지형, 게임 로그가 완전히 초기화됩니다. 계속하시겠습니까?", [
                { text: "취소", class: "bg-gray-600" },
                { text: "확인 (초기화)", class: "bg-red-600", onClick: resetAllGameData }
            ]);
        };
        document.getElementById('clear-log-btn').onclick = () => {
            showCustomModal("로그 삭제 확인", "정말로 게임 로그를 모두 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.", [
                { text: "취소", class: "bg-gray-600" },
                { text: "삭제", class: "bg-red-600", onClick: async () => {
                        await deleteLogsCollection(gameId);
                        await logAction('📜 관리자가 모든 게임 로그를 삭제했습니다.', 'admin');
                    } 
                }
            ]);
        };
        document.getElementById('open-map-edit-btn').onclick = openMapEditModal;
        document.getElementById('save-board-bg-btn').onclick = () => {
            const url = document.getElementById('board-bg-url').value.trim();
            saveBoardBackground(url);
        };
        document.getElementById('save-page-bg-btn').onclick = async () => {
            const url = document.getElementById('page-bg-url').value.trim();
            if (gameId) {
                await setDoc(doc(db, 'games', gameId), { pageBackgroundImage: url }, { merge: true });
                await logAction(`🖼️ 관리자가 전체 페이지 배경을 설정했습니다.`, "admin");
            }
        };
        document.getElementById('admin-move-toggle').onchange = async (e) => {
            const isChecked = e.target.checked;
            if (gameId) {
                await setDoc(doc(db, 'games', gameId), { isAdminMoveAllowed: isChecked }, { merge: true });
                await logAction(`👮 관리자 토큰 이동 권한이 ${isChecked ? '허용' : '제한'}되었습니다.`, "admin-move");
            }
        };
        document.querySelectorAll('.save-skill-btn').forEach(btn => {
            btn.onclick = async e => {
                const id = e.target.dataset.skillId;
                const updated = {
                    ...SKILLS[id],
                    name: document.getElementById(`admin-name-${id}`).value,
                    range: parseFloat(document.getElementById(`admin-range-${id}`).value),
                    rangeShape: document.getElementById(`admin-rangeShape-${id}`).value,
                    multiplier: parseFloat(document.getElementById(`admin-multiplier-${id}`).value),
                    type: document.getElementById(`admin-type-${id}`).value,
                    icon: document.getElementById(`admin-icon-${id}`).value,
                    category: document.getElementById(`admin-category-${id}`).value,
                    mpCost: parseInt(document.getElementById(`admin-mpcost-${id}`).value) || 0,
                    hpCost: parseInt(document.getElementById(`admin-hpcost-${id}`).value) || 0, // [수정] 누락된 hpCost 추가
                    isAoe: document.getElementById(`admin-isAoe-${id}`).checked,
                    aoeRange: parseInt(document.getElementById(`admin-aoeRange-${id}`).value) || 0,
                    aoeShape: document.getElementById(`admin-aoeShape-${id}`).value
                };
                
                const effectId = document.getElementById(`admin-effect-id-${id}`).value;
                if (effectId) {
                    const effectInfo = PREDEFINED_EFFECTS[effectId];
                    updated.appliesEffect = {
                        ...effectInfo,
                        turns: parseInt(document.getElementById(`admin-effect-turns-${id}`).value) || 0,
                        value: parseFloat(document.getElementById(`admin-effect-value-${id}`).value) || effectInfo.value || 0
                    };
                } else {
                    delete updated.appliesEffect;
                }

                if (document.getElementById(`admin-isResurrect-${id}`).checked) {
                    updated.targetType = 'ALLY_DEAD';
                } else {
                    delete updated.targetType;
                }
    
                if (gameId) {
                    const updatedSkills = { ...SKILLS, [id]: updated };
                    await setDoc(doc(db, 'games', gameId), { skills: updatedSkills }, { merge: true });
                    showCustomModal("저장 완료", `'${updated.name}' 스킬 정보가 저장되었습니다.`, [{text: "확인", class: "bg-green-600"}]);
                }
            };
        });
        document.querySelectorAll('.delete-skill-btn').forEach(btn => {
            btn.onclick = (e) => {
                const skillId = e.currentTarget.dataset.skillId;
                const skillName = e.currentTarget.dataset.skillName;
                showCustomModal("스킬 삭제 확인", `**${skillName}** 스킬을 삭제하시겠습니까? 이 스킬을 가진 모든 캐릭터에서 제거됩니다.`, [
                    { text: "취소", class: "bg-gray-600" },
                    { text: "삭제", class: "bg-red-600", onClick: () => deleteSkill(skillId, skillName) }
                ]);
            };
        });
        document.getElementById('add-new-skill-btn').onclick = async () => {
            const newId = document.getElementById('new-skill-id').value.trim();
            if (!newId || SKILLS[newId]) { showCustomModal("오류", "유효하지 않거나 중복된 스킬 ID입니다.", [{text: "확인", class: "bg-red-600"}]); return; }
            const newSkill = { id: newId, name: document.getElementById('new-skill-name').value, type: document.getElementById('new-skill-type').value, icon: document.getElementById('new-skill-icon').value, range: parseFloat(document.getElementById('new-skill-range').value) || 0, multiplier: parseFloat(document.getElementById('new-skill-multiplier').value) || 0, category: document.getElementById('new-skill-category').value, mpCost: parseInt(document.getElementById('new-skill-mpcost').value) || 0, hpCost: 0, isAoe: document.getElementById('new-skill-isAoe').checked, aoeRange: parseInt(document.getElementById('new-skill-aoeRange').value) || 0, aoeShape: document.getElementById('new-skill-aoeShape').value, rangeShape: document.getElementById('new-skill-rangeShape').value };
             const effectId = document.getElementById('new-skill-effect-id').value;
    if (effectId) {
        const effectInfo = PREDEFINED_EFFECTS[effectId];
        if (!effectId) { showCustomModal("오류", "지속 효과를 적용하려면 효과 종류를 선택해야 합니다.", [{text: "확인", class: "bg-red-600"}]); return; }
        newSkill.appliesEffect = {
             ...effectInfo,
            turns: parseInt(document.getElementById('new-skill-effect-turns').value) || 0,
            value: parseFloat(document.getElementById('new-skill-effect-value').value) || effectInfo.value || 0
        };
    }
            if (document.getElementById('new-skill-isResurrect').checked) {
        newSkill.targetType = 'ALLY_DEAD';
    }
    if (gameId) {
                await setDoc(doc(db, 'games', gameId), { skills: { ...SKILLS, [newId]: newSkill } }, { merge: true });
                showCustomModal("성공", `'${newSkill.name}' 스킬이 추가되었습니다.`, [{text: "확인", class: "bg-green-600"}]);
                openAdminModal(); 
            }
        };
        document.getElementById('add-new-char-btn').onclick = async () => {
            const name = document.getElementById('new-char-name').value.trim();
            if (!name) { showCustomModal("오류", "이름을 입력해야 합니다.", [{text: "확인", class: "bg-red-600"}]); return; }
            const type = document.getElementById('new-char-type').value;
            const skills = document.getElementById('new-char-skills').value.split(',').map(s => s.trim()).filter(Boolean);
            const newChar = { name: name, type: type, imageUrl: document.getElementById('new-char-imageUrl').value.trim(), hp: parseInt(document.getElementById('new-char-hp').value) || 100, maxHp: parseInt(document.getElementById('new-char-hp').value) || 100, mp: parseInt(document.getElementById('new-char-mp').value) || 50, maxMp: parseInt(document.getElementById('new-char-mp').value) || 50, minAttack: parseInt(document.getElementById('new-char-min-attack').value) || 10, maxAttack: parseInt(document.getElementById('new-char-max-attack').value) || 15, minDefense: parseInt(document.getElementById('new-char-min-defense').value) || 3, maxDefense: parseInt(document.getElementById('new-char-max-defense').value) || 7, size: parseInt(document.getElementById('new-char-size').value) || 1, skills: skills, x: null, y: null, password: type === 'PC' ? DEFAULT_PC_PASSWORD : '' };
            if (gameId) {
                await addDoc(collection(db, "games", gameId, "characters"), newChar);
                showCustomModal("성공", `'${newChar.name}' 캐릭터가 추가되었습니다.`, [{text: "확인", class: "bg-green-600"}]);
            }
        };

        adminModal.classList.remove('hidden');
    }

    function getSkillEditFormHtml(s) {
    const effectOptions = Object.values(PREDEFINED_EFFECTS).map(eff => 
        `<option value="${eff.id}" ${s.appliesEffect?.id === eff.id ? 'selected' : ''}>${eff.name}</option>`
    ).join('');

    return `
        <div class="grid grid-cols-4 gap-3 mt-2 text-sm">
            <div class="col-span-2"><label class="block text-xs font-medium text-gray-400">스킬 이름</label><input id="admin-name-${s.id}" class="form-input mt-1" value="${s.name}"></div>
            <div><label class="block text-xs font-medium text-gray-400">분류</label><input id="admin-category-${s.id}" class="form-input mt-1" value="${s.category || 'Other'}"></div>
            <div><label class="block text-xs font-medium text-gray-400">아이콘</label><input id="admin-icon-${s.id}" class="form-input mt-1" value="${s.icon || ''}"></div>
            <div><label class="block text-xs font-medium text-gray-400">사거리 (칸)</label><input id="admin-range-${s.id}" type="number" class="form-input mt-1" value="${s.range}"></div>
            <div>
                <label class="block text-xs font-medium text-gray-400">범위 모양</label>
                <select id="admin-rangeShape-${s.id}" class="form-input mt-1 bg-gray-700">
                    <option value="square" ${s.rangeShape === 'square' ? 'selected' : ''}>정사각형</option>
                    <option value="diamond" ${s.rangeShape === 'diamond' ? 'selected' : ''}>마름모</option>
                    <option value="cross" ${s.rangeShape === 'cross' ? 'selected' : ''}>십자</option>
                </select>
            </div>
            <div><label class="block text-xs font-medium text-gray-400">계수 (배율)</label><input id="admin-multiplier-${s.id}" type="number" step="0.1" class="form-input mt-1" value="${s.multiplier}"></div><div><label class="block text-xs font-medium text-gray-400">MP 비용</label><input id="admin-mpcost-${s.id}" type="number" class="form-input mt-1" value="${s.mpCost || 0}"></div>
            <div><label class="block text-xs font-medium text-gray-400">HP 비용</label><input id="admin-hpcost-${s.id}" type="number" class="form-input mt-1" value="${s.hpCost || 0}"></div>
            <input id="admin-type-${s.id}" type="hidden" value="${s.type}">
        </div>
        <div class="mt-3 pt-3 border-t border-gray-700 space-y-3">
            <div>
                <h5 class="font-bold text-sm mb-1 text-yellow-400">광역(AoE) 설정</h5>
                <div class="grid grid-cols-3 gap-3 items-center">
                    <div class="flex items-center gap-2"><input id="admin-isAoe-${s.id}" type="checkbox" class="form-checkbox h-5 w-5" ${s.isAoe ? 'checked' : ''}><label for="admin-isAoe-${s.id}">광역 스킬</label></div>
                    <div><label class="block text-xs font-medium text-gray-400">광역 범위</label><input id="admin-aoeRange-${s.id}" type="number" class="form-input mt-1" value="${s.aoeRange || 0}"></div>
                    <div><label class="block text-xs font-medium text-gray-400">광역 형태</label><select id="admin-aoeShape-${s.id}" class="form-input mt-1 bg-gray-700"><option value="square" ${s.aoeShape === 'square' ? 'selected' : ''}>정사각형</option><option value="diamond" ${s.aoeShape === 'diamond' ? 'selected' : ''}>마름모</option> <option value="cross">십자</option></select></div>
                </div>
            </div>
            <div>
                <h5 class="font-bold text-sm mb-1 text-cyan-400">상태 이상 효과 설정</h5>
                <div class="grid grid-cols-3 gap-3">
                    <div class="col-span-1">
                        <label class="block text-xs font-medium text-gray-400">효과 종류</label>
                        <select id="admin-effect-id-${s.id}" class="form-input mt-1 bg-gray-700">
                            <option value="">-- 효과 없음 --</option>
                            ${effectOptions}
                        </select>
                    </div>
                    <div>
                        <label class="block text-xs font-medium text-gray-400">지속 턴</label>
                        <input id="admin-effect-turns-${s.id}" type="number" class="form-input mt-1" value="${s.appliesEffect?.turns || 0}">
                    </div>
                    <div>
                        <label class="block text-xs font-medium text-gray-400">
                            값 (피해/회복/배율)
                            <span class="inline-block ml-1 text-xs bg-gray-600 text-white rounded-full w-4 h-4 text-center leading-4 cursor-help" 
                                  title="[약화]: 0~1 사이 값 (예: 0.5 = 50%로 약화)&#10;[강화]: 1보다 큰 값 (예: 1.5 = 150%로 강화)&#10;[지속 피해/회복]: 고정 수치">?</span>
                        </label>
                        <input id="admin-effect-value-${s.id}" type="number" step="0.1" class="form-input mt-1" value="${s.appliesEffect?.value || 0}">
                    </div>
                </div>
            </div>
            <div>
                <h5 class="font-bold text-sm mb-1 text-purple-400">특수 속성</h5>
                <div class="flex items-center gap-2">
                    <input id="admin-isResurrect-${s.id}" type="checkbox" class="form-checkbox h-5 w-5" ${s.targetType === 'ALLY_DEAD' ? 'checked' : ''}>
                    <label for="admin-isResurrect-${s.id}">부활 스킬 (사망한 아군을 대상으로 지정)</label>
                </div>
            </div>
        </div>
        <div class="flex justify-between items-center mt-4 pt-4 border-t border-gray-700/50">
            <button data-skill-id="${s.id}" class="save-skill-btn bg-green-600 p-2 text-sm flex-grow mr-2">저장</button>
            <button data-skill-id="${s.id}" data-skill-name="${s.name}" class="delete-skill-btn bg-red-700 hover:bg-red-600 p-2 text-sm text-white">삭제</button>
        </div>
    `;
}

    function getNewSkillFormHtml() {
    const effectOptions = Object.values(PREDEFINED_EFFECTS).map(eff => `<option value="${eff.id}">${eff.name}</option>`).join('');

    return `
        <div class="grid grid-cols-4 gap-3">
            <div class="col-span-2"><label class="block text-xs font-medium text-gray-400">스킬 ID (고유값)</label><input id="new-skill-id" class="form-input mt-1"></div>
            <div class="col-span-2"><label class="block text-xs font-medium text-gray-400">스킬 이름</label><input id="new-skill-name" class="form-input mt-1"></div>
            <div>
                <label class="block text-xs font-medium text-gray-400">분류</label>
                <select id="new-skill-category" class="form-input mt-1 bg-gray-700">${SKILL_CATEGORIES.map(c => `<option value="${c}">${c}</option>`).join('')}</select>
            </div>
            <div>
                <label class="block text-xs font-medium text-gray-400">
                    타입
                    <span class="inline-block ml-1 text-xs bg-gray-600 text-white rounded-full w-4 h-4 text-center leading-4 cursor-help" 
                          title="[Melee/Ranged]: 적을 대상으로 하는 공격 스킬입니다.&#10;[Heal/Support]: 아군을 대상으로 하는 회복/보조 스킬입니다.&#10;[Utility]: 이동 등 특수 행동에 사용됩니다.">?</span>
                </label>
                <select id="new-skill-type" class="form-input mt-1 bg-gray-700"><option value="Melee">Melee</option><option value="Ranged">Ranged</option><option value="Heal">Heal</option><option value="Support">Support</option><option value="Utility">Utility</option></select>
            </div>
            <div><label class="block text-xs font-medium text-gray-400">아이콘</label><input id="new-skill-icon" class="form-input mt-1"></div>
            <div><label class="block text-xs font-medium text-gray-400">사거리 (칸)</label><input id="new-skill-range" type="number" class="form-input mt-1"></div>
            <div>
                <label class="block text-xs font-medium text-gray-400">범위 모양</label>
                <select id="new-skill-rangeShape" class="form-input mt-1 bg-gray-700">
                    <option value="square">정사각형</option>
                    <option value="diamond">마름모</option>
                    <option value="cross">십자</option>
                </select>
            </div>
            <div><label class="block text-xs font-medium text-gray-400">계수 (배율)</label><input id="new-skill-multiplier" type="number" step="0.1" class="form-input mt-1"></div>
            <div><label class="block text-xs font-medium text-gray-400">MP 비용</label><input id="new-skill-mpcost" type="number" class="form-input mt-1" value="0"></div>
        </div>
        <div class="mt-4 pt-4 border-t border-gray-600">
            <h5 class="font-bold text-md mb-2 text-yellow-400">광역 스킬(AoE) 설정</h5>
            <div class="grid grid-cols-3 gap-4 items-center">
                <div class="flex items-center gap-2"><input id="new-skill-isAoe" type="checkbox" class="form-checkbox h-5 w-5"><label for="new-skill-isAoe">광역 스킬 여부</label></div>
                <div><label class="block text-xs font-medium text-gray-400">광역 범위</label><input id="new-skill-aoeRange" type="number" class="form-input mt-1"></div>
                <div><label class="block text-xs font-medium text-gray-400">광역 형태</label><select id="new-skill-aoeShape" class="form-input mt-1 bg-gray-700"><option value="square">정사각형</option><option value="diamond">마름모</option></select></div>
            </div>
        </div>
        <div class="mt-4 pt-4 border-t border-gray-600">
            <h5 class="font-bold text-md mb-2 text-cyan-400">상태 이상 효과 설정</h5>
            <div class="grid grid-cols-3 gap-3">
                <div class="col-span-1">
                    <label class="block text-xs font-medium text-gray-400">효과 종류</label>
                    <select id="new-skill-effect-id" class="form-input mt-1 bg-gray-700">
                        <option value="">-- 효과 없음 --</option>
                        ${effectOptions}
                    </select>
                </div>
                <div>
                    <label class="block text-xs font-medium text-gray-400">지속 턴</label>
                    <input id="new-skill-effect-turns" type="number" class="form-input mt-1">
                </div>
                <div>
                    <label class="block text-xs font-medium text-gray-400">
                        값 (피해/회복/배율)
                        <span class="inline-block ml-1 text-xs bg-gray-600 text-white rounded-full w-4 h-4 text-center leading-4 cursor-help" 
                              title="[약화]: 0~1 사이 값 (예: 0.5 = 50%로 약화)&#10;[강화]: 1보다 큰 값 (예: 1.5 = 150%로 강화)&#10;[지속 피해/회복]: 고정 수치">?</span>
                    </label>
                    <input id="new-skill-effect-value" type="number" step="0.1" class="form-input mt-1">
                </div>
            </div>
        </div>
          <div class="mt-4 pt-4 border-t border-gray-600">
            <h5 class="font-bold text-md mb-2 text-purple-400">특수 속성</h5>
            <div class="flex items-center gap-2">
                <input id="new-skill-isResurrect" type="checkbox" class="form-checkbox h-5 w-5">
                <label for="new-skill-isResurrect">부활 스킬 (사망한 아군을 대상으로 지정)</label>
            </div>
        </div>
        <button id="add-new-skill-btn" class="mt-4 bg-blue-600 p-2 w-full">새 스킬 저장</button>
    `;
}

    function getNewCharacterFormHtml() {
        return `
            <div class="grid grid-cols-2 gap-4">
                <input id="new-char-name" placeholder="이름" class="form-input">
                <select id="new-char-type" class="form-input bg-gray-700"><option value="PC">PC</option><option value="ENEMY">ENEMY</option></select>
                <input id="new-char-imageUrl" placeholder="이미지 URL" class="form-input col-span-2">
                <div class="relative"><input id="new-char-hp" type="number" placeholder=" " class="form-input peer" value="100"><label for="new-char-hp" class="absolute left-3 -top-2 text-gray-400 text-xs transition-all peer-placeholder-shown:text-base peer-placeholder-shown:top-1/2 peer-focus:-top-2 peer-focus:text-xs">HP (체력)</label></div>
                <div class="relative"><input id="new-char-mp" type="number" placeholder=" " class="form-input peer" value="50"><label for="new-char-mp" class="absolute left-3 -top-2 text-gray-400 text-xs transition-all peer-placeholder-shown:text-base peer-placeholder-shown:top-1/2 peer-focus:-top-2 peer-focus:text-xs">MP (마나)</label></div>
                <div class="relative"><input id="new-char-min-attack" type="number" placeholder=" " class="form-input peer" value="10"><label for="new-char-min-attack" class="absolute left-3 -top-2 text-gray-400 text-xs transition-all peer-placeholder-shown:text-base peer-placeholder-shown:top-1/2 peer-focus:-top-2 peer-focus:text-xs">최소 공격력</label></div>
                <div class="relative"><input id="new-char-max-attack" type="number" placeholder=" " class="form-input peer" value="15"><label for="new-char-max-attack" class="absolute left-3 -top-2 text-gray-400 text-xs transition-all peer-placeholder-shown:text-base peer-placeholder-shown:top-1/2 peer-focus:-top-2 peer-focus:text-xs">최대 공격력</label></div>
                <div class="relative"><input id="new-char-min-defense" type="number" placeholder=" " class="form-input peer" value="3"><label for="new-char-min-defense" class="absolute left-3 -top-2 text-gray-400 text-xs transition-all peer-placeholder-shown:text-base peer-placeholder-shown:top-1/2 peer-focus:-top-2 peer-focus:text-xs">최소 방어력</label></div>
                <div class="relative"><input id="new-char-max-defense" type="number" placeholder=" " class="form-input peer" value="7"><label for="new-char-max-defense" class="absolute left-3 -top-2 text-gray-400 text-xs transition-all peer-placeholder-shown:text-base peer-placeholder-shown:top-1/2 peer-focus:-top-2 peer-focus:text-xs">최대 방어력</label></div>
                <div class="relative"><input id="new-char-size" type="number" placeholder=" " class="form-input peer" value="1"><label for="new-char-size" class="absolute left-3 -top-2 text-gray-400 text-xs transition-all peer-placeholder-shown:text-base peer-placeholder-shown:top-1/2 peer-focus:-top-2 peer-focus:text-xs">크기 (1x1, 2x2...)</label></div>
                <input id="new-char-skills" placeholder="스킬 ID (e.g. slash,shoot)" class="form-input">
            </div>
            <button id="add-new-char-btn" class="mt-4 bg-blue-600 p-2 w-full">새 캐릭터 저장</button>
        </div>`;

        adminModal.classList.remove('hidden');
    }

    
    function canControlCharacter(charId) {
    const char = characters.find(c => c.id === charId);
    if (!char || char.hp <= 0) return false;

    if (isAdmin) {
        if (roundPhase === 'ENEMY_FORESHADOW' && char.type === 'ENEMY') {
            return true;
        }
        if (roundPhase === 'PLAYER_PHASE' && char.type === 'PC' && !char.hasActedThisRound) {
            return true;
        }

        if (roundPhase === 'ENEMY_EXECUTION' && isAdminMoveAllowed) {
            return true;
        }
    }

    if (roundPhase === 'PLAYER_PHASE' && loggedInCharId === charId && !char.hasActedThisRound) {
        return true;
    }
    
    return false;
}

    function isCellOccupied(targetX, targetY, movingCharId = null) {
        const isCharOccupied = characters.some(char => {
            if (char.id === movingCharId || char.x === null) return false;
            const size = char.size || 1;
            return targetX >= char.x && targetX < (char.x + size) && targetY >= char.y && targetY < (char.y + size);
        });

        const tileKey = `${targetX},${targetY}`;
        const isObstacle = boardTiles[tileKey]?.type === 'obstacle';
        
        return isCharOccupied || isObstacle;
    }

    function canPlaceCharacter(charToPlace, targetX, targetY) {
        const size = charToPlace.size || 1;
        if (targetX < 0 || targetY < 0 || targetX + size > BOARD_SIZE || targetY + size > BOARD_SIZE) return false;
        for (let i = 0; i < size; i++) {
            for (let j = 0; j < size; j++) {
                if (isCellOccupied(targetX + i, targetY + j, charToPlace.id)) return false;
            }
        }
        return true;
    }
 async function handlePreparationClick(e) {
        const cell = e.target.closest('.cell');
        if (!cell) return;

        if (isAdmin && isMapEditMode) {
            const x = parseInt(cell.dataset.x);
            const y = parseInt(cell.dataset.y);
            
            await saveBoardTile(x, y, currentTileType);
        }
    }
async function handleCombatClick(e) {
    const cell = e.target.closest('.cell');
    if (!cell) return;
    const cellX = parseInt(cell.dataset.x),
        cellY = parseInt(cell.dataset.y);

    const clickedChar = characters.find(char => {
        if (char.x === null) return false;
        const size = char.size || 1;
        return cellX >= char.x && cellX < (char.x + size) && cellY >= char.y && cellY < (char.y + size);
    });

    if (roundPhase === 'ENEMY_FORESHADOW' && isAdmin) {
        // [추가] 디버깅을 위한 로그 출력
        console.log("--- 행동 예고 클릭 감지 ---");
        console.log("클릭 전 상태:", { 
            actor: adminSelectedEnemyId, 
            skill: adminForeshadowSkillId 
        });
        console.log("클릭된 대상:", clickedChar ? clickedChar.name : "빈 칸");

        // [수정] 조건문 로직 강화
        // 1. 행동 주체와 스킬이 모두 선택된 상태에서 캐릭터를 클릭했다면, '대상 지정'으로 판단합니다.
        if (clickedChar && adminSelectedEnemyId && adminForeshadowSkillId) {
            console.log("판단: '대상 지정' 로직 실행");
            const enemy = characters.find(c => c.id === adminSelectedEnemyId);
            const skill = SKILLS[adminForeshadowSkillId];

            if (enemy && skill) {
                let isValidTarget = false;
                if ((skill.category === 'Heal' || skill.category === 'Support') && clickedChar.type === 'ENEMY') {
                    isValidTarget = true;
                } else if (skill.category === 'Attack' && clickedChar.type === 'PC') {
                    isValidTarget = true;
                }

                if (isValidTarget) {
                    console.log(`성공: ${enemy.name}의 행동을 ${clickedChar.name} 대상으로 예고합니다.`);
                    await updateDoc(doc(db, 'games', gameId, 'characters', enemy.id), {
                        nextAction: { targetId: clickedChar.id, skillId: adminForeshadowSkillId }
                    });
                    adminSelectedEnemyId = null;
                    adminForeshadowSkillId = null;
                } else {
                    console.log("실패: 유효하지 않은 대상입니다.");
                    showCustomModal("잘못된 대상", `[${skill.name}] 스킬을 해당 대상에게 사용할 수 없습니다.`, [{ text: "확인", class: "bg-yellow-600" }]);
                }
            }
        }
        // 2. 위의 경우가 아닐 때, 적 캐릭터를 클릭했다면 '행동 주체 선택'으로 판단합니다.
        else if (clickedChar && clickedChar.type === 'ENEMY') {
            console.log("판단: '행동 주체 선택' 로직 실행");
            adminSelectedEnemyId = clickedChar.id;
            adminForeshadowSkillId = null; // 스킬 선택은 초기화
        }
        // 3. 그 외의 경우 (빈 칸 클릭 등)에는 선택을 모두 초기화합니다.
        else {
            console.log("판단: 선택 초기화");
            adminSelectedEnemyId = null;
            adminForeshadowSkillId = null;
        }
        
        console.log("클릭 후 상태:", { 
            actor: adminSelectedEnemyId, 
            skill: adminForeshadowSkillId 
        });
        console.log("--------------------------");

        render();
        return;
    }

    // ... 이하 나머지 코드는 기존과 동일합니다 ...
    if (roundPhase === 'ENEMY_EXECUTION' && isAdmin) {
        const selectedCharacter = characters.find(c => c.id === selectedCharacterId);
        if (selectedCharacter && !clickedChar && !cell.classList.contains('combat-range')) {
            if (selectedCharActionPhase === 'ACTION' && preMovePosition) {
                await updateDoc(doc(db, 'games', gameId, 'characters', selectedCharacter.id), {
                    x: preMovePosition.x,
                    y: preMovePosition.y
                });
                await logAction(`↩️ ${selectedCharacter.name}의 수동 이동이 취소되었습니다.`, "system");
            }
            selectedCharacterId = null;
            selectedSkill = null;
            render();
            return;
        }
        if (selectedCharacter) {
            if (selectedCharActionPhase === 'MOVE') {
                if (cell.classList.contains('attack-range-move')) {
                    await updateDoc(doc(db, 'games', gameId, 'characters', selectedCharacter.id), { x: cellX, y: cellY });
                    selectedCharActionPhase = 'ACTION';
                    selectedSkill = null;
                    render();
                }
            } else if (selectedCharActionPhase === 'ACTION') {
                if (clickedChar && clickedChar.id === selectedCharacter.id) {
                    undoMove();
                    previewCharacterId = null;
                    return;
                }
                const skill = SKILLS[selectedSkill];
                if (skill) {
                    await executeSkill(selectedCharacter, (skill.isAoe ? { x: cellX, y: cellY } : clickedChar), selectedSkill);
                }
            }
            return;
        }
        const isActionableEnemy = clickedChar && clickedChar.type === 'ENEMY' && clickedChar.hp > 0 && clickedChar.x !== null;
        if (isActionableEnemy) {
            selectedCharacterId = clickedChar.id;
            selectedCharActionPhase = 'MOVE';
            selectedSkill = 'move';
            preMovePosition = { x: clickedChar.x, y: clickedChar.y };
            render();
            return;
        }
        return;
    }

    if (roundPhase === 'PLAYER_PHASE') {
        const selectedCharacter = characters.find(c => c.id === selectedCharacterId);

        if (selectedCharacter) {
            if (selectedCharActionPhase === 'MOVE') {
                if (cell.classList.contains('attack-range-move')) {
                    await updateDoc(doc(db, 'games', gameId, 'characters', selectedCharacter.id), { x: cellX, y: cellY });
                    selectedCharActionPhase = 'ACTION';
                    selectedSkill = null;
                    render();
                    return;
                }
                if (clickedChar && clickedChar.id === selectedCharacter.id) {
                    selectedCharActionPhase = 'ACTION';
                    selectedSkill = null;
                    render();
                    return;
                }
                selectedCharacterId = null;
                selectedSkill = null;
                render();
                return;

            } else if (selectedCharActionPhase === 'ACTION') {
                if (clickedChar && clickedChar.id === selectedCharacter.id) {
                    undoMove();
                    return;
                }
                const skill = SKILLS[selectedSkill];
                if (skill && cell.classList.contains('combat-range')) {
                    await executeSkill(selectedCharacter, (skill.isAoe || !clickedChar ? { x: cellX, y: cellY } : clickedChar), selectedSkill);
                    return;
                }
                undoMove();
                selectedCharacterId = null;
                selectedSkill = null;
                render();
                return;
            }
        } else {
            if (clickedChar && clickedChar.hp > 0) {
                const canAdminActForPC = isAdmin && clickedChar.type === 'PC' && !clickedChar.hasActedThisRound;
                const canPlayerSelect = loggedInCharId === clickedChar.id && clickedChar.type === 'PC' && !clickedChar.hasActedThisRound;

                if (canAdminActForPC || canPlayerSelect) {
                    selectedCharacterId = clickedChar.id;
                    selectedCharActionPhase = 'MOVE';
                    selectedSkill = 'move';
                    preMovePosition = { x: clickedChar.x, y: clickedChar.y };
                    previewCharacterId = null;
                    if (canAdminActForPC) {
                        await logAction(`👮 관리자가 ${clickedChar.name}의 행동을 대리합니다.`, 'admin');
                    }
                } else {
                    previewCharacterId = clickedChar.id;
                    selectedCharacterId = null;
                }
            } else {
                previewCharacterId = null;
                selectedCharacterId = null;
            }
            render();
        }
    }
}
    async function gameBoardClick(e) {
        if(!gameId) return;
        if (gameState === 'PREPARATION') {
            await handlePreparationClick(e);
        } else if (gameState === 'STARTED') {
            await handleCombatClick(e);
        }
    }
    
    // --- Map Edit Modal Listeners ---
    document.querySelectorAll('.tile-select-btn').forEach(btn => {
        loginStatusBtn.addEventListener('click', () => {
    loginStatusModal.classList.remove('hidden');
});

document.getElementById('close-login-status-modal-btn').onclick = () => {
    closeModal('login-status-modal');
};

loginStatusModal.addEventListener('click', (e) => {
    if (e.target.id === 'login-status-modal') {
        closeModal('login-status-modal');
    }
});

createGameBtn.addEventListener('click', createGame);
        btn.onclick = (e) => {
            currentTileType = e.currentTarget.dataset.tileType;
            document.getElementById('map-edit-status').textContent = `현재 선택: ${e.currentTarget.textContent.trim()}`;
        };
    });

    // "맵 편집 종료" 버튼만 isMapEditMode를 false로 설정합니다.
    document.getElementById('exit-map-edit-btn').onclick = confirmExitMapEditMode;
    
    // 'X' 버튼과 배경 클릭은 팝업만 닫고 isMapEditMode는 유지합니다.
    document.getElementById('close-map-edit-modal-btn').onclick = hideMapEditModalTemporarily; 
    mapEditModal.addEventListener('click', e => { 
        // Close only if the backdrop itself (map-edit-modal) is clicked
        if (e.target.id === 'map-edit-modal') hideMapEditModalTemporarily(); 
    });
    // --- End Map Edit Modal Listeners ---


    createGameBtn.addEventListener('click', createGame);
    joinGameBtn.addEventListener('click', () => joinGame(gameIdInput.value));
    leaveGameBtn.addEventListener('click', leaveGame);
    
    // User Info Modal Handlers
    userInfoBtn.addEventListener('click', () => { userInfoModal.classList.remove('hidden'); });
    // Fix: Use the dedicated button ID to close the User Info Modal
    document.getElementById('close-user-info-modal-btn').onclick = () => closeModal('user-info-modal');
    userInfoModal.addEventListener('click', (e) => { 
        // Only close if backdrop is clicked
        if (e.target.id === 'user-info-modal') closeModal('user-info-modal'); 
    });
    
    // Copy button inside User Info Modal
    document.getElementById('user-info-copy-btn').addEventListener('click', () => { 
        const input = document.getElementById('user-info-game-id-display');
        input.select(); 
        if (navigator.clipboard && window.isSecureContext) {
            navigator.clipboard.writeText(input.value).then(() => {
                showCustomModal("복사 완료", "게임 코드가 클립보드에 복사되었습니다. (Modern API)", [{ text: "확인", class: "bg-green-600" }]);
            }).catch(err => {
                document.execCommand('copy');
                showCustomModal("복사 완료", "게임 코드가 클립보드에 복사되었습니다. (Fallback)", [{ text: "확인", class: "bg-green-600" }]);
                console.error('Async clipboard copy failed:', err);
            });
        } else {
             document.execCommand('copy');
             showCustomModal("복사 완료", "게임 코드가 클립보드에 복사되었습니다.", [{ text: "확인", class: "bg-green-600" }]);
        }
    });

    // Original Game ID container copy logic (still needed if the original container is shown in the lobby phase)
    copyGameIdBtn.addEventListener('click', () => { 
        const input = document.getElementById('game-id-display');
        input.select(); 
        if (navigator.clipboard && window.isSecureContext) {
            navigator.clipboard.writeText(input.value).then(() => {
                showCustomModal("복사 완료", "게임 코드가 클립보드에 복사되었습니다. (Modern API)", [{ text: "확인", class: "bg-green-600" }]);
            }).catch(err => {
                document.execCommand('copy');
                showCustomModal("복사 완료", "게임 코드가 클립보드에 복사되었습니다. (Fallback)", [{ text: "확인", class: "bg-green-600" }]);
                console.error('Async clipboard copy failed:', err);
            });
        } else {
             document.execCommand('copy');
             showCustomModal("복사 완료", "게임 코드가 클립보드에 복사되었습니다.", [{ text: "확인", class: "bg-green-600" }]);
        }
    });
    
    document.getElementById('overlay-toggle').addEventListener('click', (e) => {
         const overlay = document.getElementById('character-selection-overlay');
         overlay.classList.toggle('collapsed');
         e.currentTarget.querySelector('svg').style.transform = overlay.classList.contains('collapsed') ? 'rotate(180deg)' : 'rotate(0deg)';
    });
    profileModal.addEventListener('click', e => { if (e.target.id === 'profile-modal') closeModal('profile-modal'); });
    
    document.getElementById('submit-char-login-btn').addEventListener('click', handlePCLogin);
    document.getElementById('cancel-char-login-btn').addEventListener('click', () => closeModal('pc-login-modal'));
    // Re-route original login/logout button handlers
    // document.getElementById('login-btn').addEventListener('click', openPCLoginModal); // Removed, now handled by User Info Modal
    // document.getElementById('logout-btn').addEventListener('click', handleLogout); // Removed, now handled by User Info Modal
    pcLoginModal.addEventListener('click', e => { if (e.target.id === 'pc-login-modal') closeModal('pc-login-modal'); });
    
    document.getElementById('admin-panel-btn').addEventListener('click', () => { 
        if (isAdmin) {
            openAdminModal();
        } else {
            adminPasswordModal.classList.remove('hidden'); document.getElementById('admin-password-input').focus();
        }
    });
    document.getElementById('cancel-admin-login-btn').addEventListener('click', () => closeModal('admin-password-modal'));
    
    document.getElementById('submit-admin-login-btn').addEventListener('click', async () => {
        const input = document.getElementById('admin-password-input');
        const errorP = document.getElementById('admin-password-error');
        if (gameId) {
            const gameDoc = await getDoc(doc(db, 'games', gameId));

            const correctPassword = gameDoc.data().adminPassword || "7251";
            if (input.value === correctPassword) {
                closeModal('admin-password-modal');
                isAdmin = true;
                loggedInCharId = null;
                openAdminModal();
                input.value = '';
                errorP.textContent = '';
                updateAuthStatus();
                    render();
                await logAction("👑 관리자가 로그인했습니다.", "system");
            } else {
                errorP.textContent = '비밀번호가 올바르지 않습니다.';
                input.value = '';
            }
        }
    });

    gameBoard.addEventListener('click', gameBoardClick);
    gameBoard.addEventListener('dragover', e => e.preventDefault());
    async function handleDropOnCell(charId, cell) {
    if (!gameId || !cell || !charId) return;

    const targetChar = characters.find(c => c.id === charId);
    if (!targetChar) return;

    const canDragAndDrop = (isAdmin && isAdminMoveAllowed) || 
                           (gameState === 'PREPARATION' && targetChar.type === 'PC' && (isAdmin || loggedInCharId === charId)) ||
                           (gameState === 'STARTED' && targetChar.type === 'PC' && loggedInCharId === charId && selectedCharacterId === charId);

    if (canDragAndDrop) {
        const newX = parseInt(cell.dataset.x);
        const newY = parseInt(cell.dataset.y);

        if (canPlaceCharacter(targetChar, newX, newY)) {
            const oldX = targetChar.x;
            await updateDoc(doc(db, 'games', gameId, 'characters', charId), { x: newX, y: newY });
            
            if (oldX === null) {
               await logAction(`✅ ${targetChar.name}이(가) 전장에 합류했습니다.`, "join");
            } else if (isAdmin && isAdminMoveAllowed) {
               await logAction(`👮 관리자가 ${targetChar.name}을(를) (${oldX},${targetChar.y})에서 (${newX}, ${newY})로 이동했습니다.`, "admin-move");
            } else {
                await logAction(`🏃 ${targetChar.name}이(가) (${oldX},${targetChar.y})에서 (${newX}, ${newY})로 이동했습니다.`, "move");
            }
        } else {
             showCustomModal("배치 오류", "해당 위치는 이미 다른 캐릭터가 차지하고 있거나 장애물입니다.", [{ text: "확인", class: "bg-red-600" }]);
        }
    } else {
        showCustomModal("권한 부족", "캐릭터를 배치하거나 이동할 권한이 없습니다.", [{ text: "확인", class: "bg-red-600" }]);
    }
}

gameBoard.addEventListener('drop', async e => {
    e.preventDefault();
    const charId = e.dataTransfer.getData('text/plain');
    const cell = e.target.closest('.cell');
    await handleDropOnCell(charId, cell);
});
 async function saveSettingsToFile() {
        if (!gameId) return;

        const settingsToSave = {
            gameSettings: {
                skills: SKILLS,
                maxRounds: maxRounds,
                boardBackgroundImage: boardBackgroundImage,
                pageBackgroundImage: pageBackgroundImage,
                isAdminMoveAllowed: isAdminMoveAllowed
            },
            boardTiles: boardTiles,
            characters: characters.map(({ id, ...char }) => char) // id는 Firestore에서 자동 생성되므로 제외
        };

        // 2. 객체를 JSON 문자열로 변환합니다.
        const jsonString = JSON.stringify(settingsToSave, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        // 3. 가상의 링크를 만들어 다운로드를 실행합니다.
        const a = document.createElement('a');
        a.href = url;
        const timestamp = new Date().toISOString().slice(0, 19).replace(/[:T]/g, '-');
        a.download = `game-settings-${gameId}-${timestamp}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        await logAction("💾 관리자가 현재 게임 설정을 파일로 저장했습니다.", "admin");
    }

    async function loadSettingsFromFile(file) {
        if (!file) return;

        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                const settings = JSON.parse(e.target.result);

                // 파일 유효성 검사
                if (!settings.gameSettings || !settings.boardTiles || !settings.characters) {
                    throw new Error("올바르지 않은 설정 파일 형식입니다.");
                }

                showCustomModal("설정 불러오기 확인", "정말로 파일에서 설정을 불러오시겠습니까? 현재 게임의 모든 캐릭터, 스킬, 맵 설정이 파일의 내용으로 **완전히 교체**됩니다. 이 작업은 되돌릴 수 없습니다.", [
                    { text: "취소", class: "bg-gray-600" },
                    { text: "확인 (덮어쓰기)", class: "bg-red-600", onClick: async () => {
                        
                        // 1. 기존 캐릭터 데이터를 모두 삭제합니다.
                        const charCollectionRef = collection(db, "games", gameId, "characters");
                        const snapshot = await getDocs(charCollectionRef);
                        const deleteBatch = writeBatch(db);
                        snapshot.docs.forEach(doc => deleteBatch.delete(doc.ref));
                        await deleteBatch.commit();

                        // 2. 파일에서 읽어온 새 캐릭터 데이터를 추가합니다.
                        const addBatch = writeBatch(db);
                        settings.characters.forEach(charData => {
                            const newCharRef = doc(collection(db, "games", gameId, "characters"));
                            addBatch.set(newCharRef, charData);
                        });
                        await addBatch.commit();

                        // 3. 나머지 게임 설정을 업데이트합니다.
                        const gameDocRef = doc(db, 'games', gameId);
                        await updateDoc(gameDocRef, settings.gameSettings);

                        // 4. 맵 타일 정보를 업데이트합니다.
                        const boardDocRef = doc(db, 'games', gameId, 'board', 'tiles');
                        await setDoc(boardDocRef, { tiles: settings.boardTiles });

                        await logAction("📂 관리자가 파일에서 게임 설정을 불러왔습니다. 모든 데이터가 교체되었습니다.", "admin");
                        showCustomModal("성공", "설정을 성공적으로 불러왔습니다. 페이지가 새로고침됩니다.", [{text: "확인", class: "bg-green-600", onClick: () => location.reload()}]);
                    }}
                ]);

            } catch (error) {
                console.error("설정 파일 불러오기 실패:", error);
                showCustomModal("오류", "설정 파일을 읽는 중 오류가 발생했습니다. 파일이 손상되었거나 형식이 올바르지 않습니다.", [{text: "확인", class: "bg-red-600"}]);
            }
        };
        reader.readAsText(file);
    }

    adminModal.addEventListener('click', e => {
        // 클릭된 대상(e.target)이 모달의 배경(id: admin-modal) 자체일 때만 닫습니다.
        if (e.target.id === 'admin-modal') {
            closeModal('admin-modal');
        }
    });
    
    const applyTheme = (theme) => {
        document.documentElement.classList.toggle('light', theme === 'light');
        // Re-render to ensure scrollbars update correctly on theme change (due to CSS variable change)
        render(); 
    }
    document.getElementById('theme-toggle-btn').addEventListener('click', () => {
        const newTheme = document.documentElement.classList.contains('light') ? 'dark' : 'light';
        localStorage.setItem('theme', newTheme);
        applyTheme(newTheme);
    });
    applyTheme(localStorage.getItem('theme') || 'dark');

function initializeTouchDragAndDrop() {
    const selectionOverlay = document.getElementById('character-selection-overlay');
    const ghost = document.getElementById('drag-ghost');
    let draggedCharId = null;
    let lastOverCell = null;

    const onTouchMove = (e) => {
        if (!draggedCharId) return;
        
        const touch = e.touches[0];
        ghost.style.left = `${touch.clientX - ghost.offsetWidth / 2}px`;
        ghost.style.top = `${touch.clientY - ghost.offsetHeight / 2}px`;

        const elementUnder = document.elementFromPoint(touch.clientX, touch.clientY);
        const currentOverCell = elementUnder ? elementUnder.closest('.cell') : null;

        if (currentOverCell !== lastOverCell) {
            if (lastOverCell) {
                lastOverCell.classList.remove('drag-over');
            }
            if (currentOverCell) {
                currentOverCell.classList.add('drag-over');
            }
            lastOverCell = currentOverCell;
        }
    };

    const onTouchEnd = async (e) => {
        if (!draggedCharId) return;

        if (lastOverCell) {
            lastOverCell.classList.remove('drag-over');
            await handleDropOnCell(draggedCharId, lastOverCell);
        }

        ghost.classList.add('hidden');
        draggedCharId = null;
        lastOverCell = null;
        document.removeEventListener('touchmove', onTouchMove);
        document.removeEventListener('touchend', onTouchEnd);
    };

    selectionOverlay.addEventListener('touchstart', (e) => {
        const card = e.target.closest('.char-card-item[draggable="true"]');
        if (!card) return;
        
        e.preventDefault();
        
        draggedCharId = card.dataset.charId;
        const touch = e.touches[0];

        ghost.style.left = `${touch.clientX - ghost.offsetWidth / 2}px`;
        ghost.style.top = `${touch.clientY - ghost.offsetHeight / 2}px`;
        ghost.classList.remove('hidden');

        document.addEventListener('touchmove', onTouchMove);
        document.addEventListener('touchend', onTouchEnd);
    }, { passive: false });
}

initializeTouchDragAndDrop();
    const charListHeader = document.getElementById('char-list-header');
    const charListContent = document.getElementById('char-list-content');
    const charListToggleIcon = document.getElementById('char-list-toggle-icon');

    if (charListHeader && charListContent && charListToggleIcon) {
        charListHeader.addEventListener('click', () => {
            if (window.innerWidth >= 1024) {
                return;
            }
            
            charListContent.classList.toggle('hidden');
            
            charListToggleIcon.classList.toggle('rotate-180');
        });
    }

    if (window.innerWidth < 1024) {
        charListContent.classList.add('hidden');
        charListToggleIcon.classList.remove('rotate-180');
    } else {
        charListContent.classList.remove('hidden');
    }
window.addEventListener('beforeunload', async (event) => {
    if (loggedInCharId) {
        await updateDoc(doc(db, 'games', gameId, 'characters', loggedInCharId), { isLoggedIn: false });
    }
});
</script>
</body>
</html>